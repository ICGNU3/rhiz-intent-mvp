"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/force-graph";
exports.ids = ["vendor-chunks/force-graph"];
exports.modules = {

/***/ "(ssr)/./node_modules/force-graph/dist/force-graph.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/force-graph/dist/force-graph.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ forceGraph)\n/* harmony export */ });\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/min.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/max.js\");\n/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-array */ \"(ssr)/./node_modules/d3-array/src/sum.js\");\n/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash-es */ \"(ssr)/./node_modules/lodash-es/throttle.js\");\n/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tweenjs/tween.js */ \"(ssr)/./node_modules/@tweenjs/tween.js/dist/tween.esm.js\");\n/* harmony import */ var kapsule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! kapsule */ \"(ssr)/./node_modules/kapsule/dist/kapsule.mjs\");\n/* harmony import */ var accessor_fn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! accessor-fn */ \"(ssr)/./node_modules/accessor-fn/dist/accessor-fn.mjs\");\n/* harmony import */ var canvas_color_tracker__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! canvas-color-tracker */ \"(ssr)/./node_modules/canvas-color-tracker/dist/canvas-color-tracker.mjs\");\n/* harmony import */ var float_tooltip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! float-tooltip */ \"(ssr)/./node_modules/float-tooltip/dist/float-tooltip.mjs\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/simulation.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/link.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/manyBody.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/center.js\");\n/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-force-3d */ \"(ssr)/./node_modules/d3-force-3d/src/radial.js\");\n/* harmony import */ var bezier_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bezier-js */ \"(ssr)/./node_modules/bezier-js/src/bezier.js\");\n/* harmony import */ var index_array_by__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! index-array-by */ \"(ssr)/./node_modules/index-array-by/dist/index-array-by.mjs\");\n/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ \"(ssr)/./node_modules/d3-scale/src/ordinal.js\");\n/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale-chromatic */ \"(ssr)/./node_modules/d3-scale-chromatic/src/categorical/Paired.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction styleInject(css, ref) {\n  if (ref === void 0) ref = {};\n  var insertAt = ref.insertAt;\n  if (typeof document === 'undefined') {\n    return;\n  }\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".force-graph-container canvas {\\n  display: block;\\n  user-select: none;\\n  outline: none;\\n  -webkit-tap-highlight-color: transparent;\\n}\\n\\n.force-graph-container .clickable {\\n  cursor: pointer;\\n}\\n\\n.force-graph-container .grabbable {\\n  cursor: move;\\n  cursor: grab;\\n  cursor: -moz-grab;\\n  cursor: -webkit-grab;\\n}\\n\\n.force-graph-container .grabbable:active {\\n  cursor: grabbing;\\n  cursor: -moz-grabbing;\\n  cursor: -webkit-grabbing;\\n}\\n\";\nstyleInject(css_248z);\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return p;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r);\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nvar autoColorScale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n// Autoset attribute colorField by colorByAccessor property\n// If an object has already a color, don't set it\n// Objects can be nodes or links\nfunction autoColorObjects(objects, colorByAccessor, colorField) {\n  if (!colorByAccessor || typeof colorField !== 'string') return;\n  objects.filter(function (obj) {\n    return !obj[colorField];\n  }).forEach(function (obj) {\n    obj[colorField] = autoColorScale(colorByAccessor(obj));\n  });\n}\n\nfunction getDagDepths (_ref, idAccessor) {\n  var nodes = _ref.nodes,\n    links = _ref.links;\n  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref2$nodeFilter = _ref2.nodeFilter,\n    nodeFilter = _ref2$nodeFilter === void 0 ? function () {\n      return true;\n    } : _ref2$nodeFilter,\n    _ref2$onLoopError = _ref2.onLoopError,\n    onLoopError = _ref2$onLoopError === void 0 ? function (loopIds) {\n      throw \"Invalid DAG structure! Found cycle in node path: \".concat(loopIds.join(' -> '), \".\");\n    } : _ref2$onLoopError;\n  // linked graph\n  var graph = {};\n  nodes.forEach(function (node) {\n    return graph[idAccessor(node)] = {\n      data: node,\n      out: [],\n      depth: -1,\n      skip: !nodeFilter(node)\n    };\n  });\n  links.forEach(function (_ref3) {\n    var source = _ref3.source,\n      target = _ref3.target;\n    var sourceId = getNodeId(source);\n    var targetId = getNodeId(target);\n    if (!graph.hasOwnProperty(sourceId)) throw \"Missing source node with id: \".concat(sourceId);\n    if (!graph.hasOwnProperty(targetId)) throw \"Missing target node with id: \".concat(targetId);\n    var sourceNode = graph[sourceId];\n    var targetNode = graph[targetId];\n    sourceNode.out.push(targetNode);\n    function getNodeId(node) {\n      return _typeof(node) === 'object' ? idAccessor(node) : node;\n    }\n  });\n  var foundLoops = [];\n  traverse(Object.values(graph));\n  var nodeDepths = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(graph).filter(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      node = _ref5[1];\n    return !node.skip;\n  }).map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      id = _ref7[0],\n      node = _ref7[1];\n    return _defineProperty({}, id, node.depth);\n  }))));\n  return nodeDepths;\n  function traverse(nodes) {\n    var nodeStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var currentDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var _loop = function _loop() {\n      var node = nodes[i];\n      if (nodeStack.indexOf(node) !== -1) {\n        var loop = [].concat(_toConsumableArray(nodeStack.slice(nodeStack.indexOf(node))), [node]).map(function (d) {\n          return idAccessor(d.data);\n        });\n        if (!foundLoops.some(function (foundLoop) {\n          return foundLoop.length === loop.length && foundLoop.every(function (id, idx) {\n            return id === loop[idx];\n          });\n        })) {\n          foundLoops.push(loop);\n          onLoopError(loop);\n        }\n        return 1; // continue\n      }\n      if (currentDepth > node.depth) {\n        // Don't unnecessarily revisit chunks of the graph\n        node.depth = currentDepth;\n        traverse(node.out, [].concat(_toConsumableArray(nodeStack), [node]), currentDepth + (node.skip ? 0 : 1));\n      }\n    };\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      if (_loop()) continue;\n    }\n  }\n}\n\n//\n\nvar DAG_LEVEL_NODE_RATIO = 2;\n\n// whenever styling props are changed that require a canvas redraw\nvar notifyRedraw = function notifyRedraw(_, state) {\n  return state.onNeedsRedraw && state.onNeedsRedraw();\n};\nvar updDataPhotons = function updDataPhotons(_, state) {\n  if (!state.isShadow) {\n    // Add photon particles\n    var linkParticlesAccessor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n    state.graphData.links.forEach(function (link) {\n      var numPhotons = Math.round(Math.abs(linkParticlesAccessor(link)));\n      if (numPhotons) {\n        link.__photons = _toConsumableArray(Array(numPhotons)).map(function () {\n          return {};\n        });\n      } else {\n        delete link.__photons;\n      }\n    });\n  }\n};\nvar CanvasForceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n  props: {\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(_, state) {\n        state.engineRunning = false; // Pause simulation\n        updDataPhotons(_, state);\n      }\n    },\n    dagMode: {\n      onChange: function onChange(dagMode, state) {\n        // td, bu, lr, rl, radialin, radialout\n        !dagMode && (state.graphData.nodes || []).forEach(function (n) {\n          return n.fx = n.fy = undefined;\n        }); // unfix nodes when disabling dag mode\n      }\n    },\n    dagLevelDistance: {},\n    dagNodeFilter: {\n      \"default\": function _default(node) {\n        return true;\n      }\n    },\n    onDagError: {\n      triggerUpdate: false\n    },\n    nodeRelSize: {\n      \"default\": 4,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // area per val unit\n    nodeId: {\n      \"default\": 'id'\n    },\n    nodeVal: {\n      \"default\": 'val',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeAutoColorBy: {},\n    nodeCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    nodeVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkSource: {\n      \"default\": 'source'\n    },\n    linkTarget: {\n      \"default\": 'target'\n    },\n    linkVisibility: {\n      \"default\": true,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkColor: {\n      \"default\": 'color',\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkAutoColorBy: {},\n    linkLineDash: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkWidth: {\n      \"default\": 1,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCurvature: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObject: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkCanvasObjectMode: {\n      \"default\": function _default() {\n        return 'replace';\n      },\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowLength: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowColor: {\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    linkDirectionalArrowRelPos: {\n      \"default\": 0.5,\n      triggerUpdate: false,\n      onChange: notifyRedraw\n    },\n    // value between 0<>1 indicating the relative pos along the (exposed) line\n    linkDirectionalParticles: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: updDataPhotons\n    },\n    // animate photons travelling in the link direction\n    linkDirectionalParticleSpeed: {\n      \"default\": 0.01,\n      triggerUpdate: false\n    },\n    // in link length ratio per frame\n    linkDirectionalParticleOffset: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // starting position offset along the link's length, like a pre-delay. Values between [0, 1]\n    linkDirectionalParticleWidth: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    linkDirectionalParticleColor: {\n      triggerUpdate: false\n    },\n    linkDirectionalParticleCanvasObject: {\n      triggerUpdate: false\n    },\n    globalScale: {\n      \"default\": 1,\n      triggerUpdate: false\n    },\n    d3AlphaMin: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    d3AlphaDecay: {\n      \"default\": 0.0228,\n      triggerUpdate: false,\n      onChange: function onChange(alphaDecay, state) {\n        state.forceLayout.alphaDecay(alphaDecay);\n      }\n    },\n    d3AlphaTarget: {\n      \"default\": 0,\n      triggerUpdate: false,\n      onChange: function onChange(alphaTarget, state) {\n        state.forceLayout.alphaTarget(alphaTarget);\n      }\n    },\n    d3VelocityDecay: {\n      \"default\": 0.4,\n      triggerUpdate: false,\n      onChange: function onChange(velocityDecay, state) {\n        state.forceLayout.velocityDecay(velocityDecay);\n      }\n    },\n    warmupTicks: {\n      \"default\": 0,\n      triggerUpdate: false\n    },\n    // how many times to tick the force engine at init before starting to render\n    cooldownTicks: {\n      \"default\": Infinity,\n      triggerUpdate: false\n    },\n    cooldownTime: {\n      \"default\": 15000,\n      triggerUpdate: false\n    },\n    // ms\n    onUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onFinishUpdate: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineTick: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onEngineStop: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNeedsRedraw: {\n      triggerUpdate: false\n    },\n    isShadow: {\n      \"default\": false,\n      triggerUpdate: false\n    }\n  },\n  methods: {\n    // Expose d3 forces for external manipulation\n    d3Force: function d3Force(state, forceName, forceFn) {\n      if (forceFn === undefined) {\n        return state.forceLayout.force(forceName); // Force getter\n      }\n      state.forceLayout.force(forceName, forceFn); // Force setter\n      return this;\n    },\n    d3ReheatSimulation: function d3ReheatSimulation(state) {\n      state.forceLayout.alpha(1);\n      this.resetCountdown();\n      return this;\n    },\n    // reset cooldown state\n    resetCountdown: function resetCountdown(state) {\n      state.cntTicks = 0;\n      state.startTickTime = new Date();\n      state.engineRunning = true;\n      return this;\n    },\n    isEngineRunning: function isEngineRunning(state) {\n      return !!state.engineRunning;\n    },\n    tickFrame: function tickFrame(state) {\n      !state.isShadow && layoutTick();\n      paintLinks();\n      !state.isShadow && paintArrows();\n      !state.isShadow && paintPhotons();\n      paintNodes();\n      return this;\n\n      //\n\n      function layoutTick() {\n        if (state.engineRunning) {\n          if (++state.cntTicks > state.cooldownTicks || new Date() - state.startTickTime > state.cooldownTime || state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin) {\n            state.engineRunning = false; // Stop ticking graph\n            state.onEngineStop();\n          } else {\n            state.forceLayout.tick(); // Tick it\n            state.onEngineTick();\n          }\n        }\n      }\n      function paintNodes() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVisibility);\n        var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeColor);\n        var getNodeCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow / state.globalScale;\n        var visibleNodes = state.graphData.nodes.filter(getVisibility);\n        ctx.save();\n        visibleNodes.forEach(function (node) {\n          var nodeCanvasObjectMode = getNodeCanvasObjectMode(node);\n          if (state.nodeCanvasObject && (nodeCanvasObjectMode === 'before' || nodeCanvasObjectMode === 'replace')) {\n            // Custom node before/replace paint\n            state.nodeCanvasObject(node, ctx, state.globalScale);\n            if (nodeCanvasObjectMode === 'replace') {\n              ctx.restore();\n              return;\n            }\n          }\n\n          // Draw wider nodes by 1px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n          var r = Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize + padAmount;\n          ctx.beginPath();\n          ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);\n          ctx.fillStyle = getColor(node) || 'rgba(31, 120, 180, 0.92)';\n          ctx.fill();\n          if (state.nodeCanvasObject && nodeCanvasObjectMode === 'after') {\n            // Custom node after paint\n            state.nodeCanvasObject(node, state.ctx, state.globalScale);\n          }\n        });\n        ctx.restore();\n      }\n      function paintLinks() {\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkColor);\n        var getWidth = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth);\n        var getLineDash = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkLineDash);\n        var getCurvature = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCurvature);\n        var getLinkCanvasObjectMode = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkCanvasObjectMode);\n        var ctx = state.ctx;\n\n        // Draw wider lines by 2px on shadow canvas for more precise hovering (due to boundary anti-aliasing)\n        var padAmount = state.isShadow * 2;\n        var visibleLinks = state.graphData.links.filter(getVisibility);\n        visibleLinks.forEach(calcLinkControlPoints); // calculate curvature control points for all visible links\n\n        var beforeCustomLinks = [],\n          afterCustomLinks = [],\n          defaultPaintLinks = visibleLinks;\n        if (state.linkCanvasObject) {\n          var replaceCustomLinks = [],\n            otherCustomLinks = [];\n          visibleLinks.forEach(function (d) {\n            return ({\n              before: beforeCustomLinks,\n              after: afterCustomLinks,\n              replace: replaceCustomLinks\n            }[getLinkCanvasObjectMode(d)] || otherCustomLinks).push(d);\n          });\n          defaultPaintLinks = [].concat(_toConsumableArray(beforeCustomLinks), afterCustomLinks, otherCustomLinks);\n          beforeCustomLinks = beforeCustomLinks.concat(replaceCustomLinks);\n        }\n\n        // Custom link before paints\n        ctx.save();\n        beforeCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        // Bundle strokes per unique color/width/dash for performance optimization\n        var linksPerColor = (0,index_array_by__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(defaultPaintLinks, [getColor, getWidth, getLineDash]);\n        ctx.save();\n        Object.entries(linksPerColor).forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            color = _ref2[0],\n            linksPerWidth = _ref2[1];\n          var lineColor = !color || color === 'undefined' ? 'rgba(0,0,0,0.15)' : color;\n          Object.entries(linksPerWidth).forEach(function (_ref3) {\n            var _ref4 = _slicedToArray(_ref3, 2),\n              width = _ref4[0],\n              linesPerLineDash = _ref4[1];\n            var lineWidth = (width || 1) / state.globalScale + padAmount;\n            Object.entries(linesPerLineDash).forEach(function (_ref5) {\n              var _ref6 = _slicedToArray(_ref5, 2);\n                _ref6[0];\n                var links = _ref6[1];\n              var lineDashSegments = getLineDash(links[0]);\n              ctx.beginPath();\n              links.forEach(function (link) {\n                var start = link.source;\n                var end = link.target;\n                if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n                ctx.moveTo(start.x, start.y);\n                var controlPoints = link.__controlPoints;\n                if (!controlPoints) {\n                  // Straight line\n                  ctx.lineTo(end.x, end.y);\n                } else {\n                  // Use quadratic curves for regular lines and bezier for loops\n                  ctx[controlPoints.length === 2 ? 'quadraticCurveTo' : 'bezierCurveTo'].apply(ctx, _toConsumableArray(controlPoints).concat([end.x, end.y]));\n                }\n              });\n              ctx.strokeStyle = lineColor;\n              ctx.lineWidth = lineWidth;\n              ctx.setLineDash(lineDashSegments || []);\n              ctx.stroke();\n            });\n          });\n        });\n        ctx.restore();\n\n        // Custom link after paints\n        ctx.save();\n        afterCustomLinks.forEach(function (link) {\n          return state.linkCanvasObject(link, ctx, state.globalScale);\n        });\n        ctx.restore();\n\n        //\n\n        function calcLinkControlPoints(link) {\n          var curvature = getCurvature(link);\n          if (!curvature) {\n            // straight line\n            link.__controlPoints = null;\n            return;\n          }\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var l = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2)); // line length\n\n          if (l > 0) {\n            var a = Math.atan2(end.y - start.y, end.x - start.x); // line angle\n            var d = l * curvature; // control point distance\n\n            var cp = {\n              // control point\n              x: (start.x + end.x) / 2 + d * Math.cos(a - Math.PI / 2),\n              y: (start.y + end.y) / 2 + d * Math.sin(a - Math.PI / 2)\n            };\n            link.__controlPoints = [cp.x, cp.y];\n          } else {\n            // Same point, draw a loop\n            var _d = curvature * 70;\n            link.__controlPoints = [end.x, end.y - _d, end.x + _d, end.y];\n          }\n        }\n      }\n      function paintArrows() {\n        var ARROW_WH_RATIO = 1.6;\n        var ARROW_VLEN_RATIO = 0.2;\n        var getLength = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowLength);\n        var getRelPos = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowRelPos);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalArrowColor || state.linkColor);\n        var getNodeVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var arrowLength = getLength(link);\n          if (!arrowLength || arrowLength < 0) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var startR = Math.sqrt(Math.max(0, getNodeVal(start) || 1)) * state.nodeRelSize;\n          var endR = Math.sqrt(Math.max(0, getNodeVal(end) || 1)) * state.nodeRelSize;\n          var arrowRelPos = Math.min(1, Math.max(0, getRelPos(link)));\n          var arrowColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          var arrowHalfWidth = arrowLength / ARROW_WH_RATIO / 2;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints && _construct(bezier_js__WEBPACK_IMPORTED_MODULE_4__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y]));\n          var getCoordsAlongLine = bzLine ? function (t) {\n            return bzLine.get(t);\n          } // get position along bezier line\n          : function (t) {\n            return {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * t || 0,\n              y: start.y + (end.y - start.y) * t || 0\n            };\n          };\n          var lineLen = bzLine ? bzLine.length() : Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n          var posAlongLine = startR + arrowLength + (lineLen - startR - endR - arrowLength) * arrowRelPos;\n          var arrowHead = getCoordsAlongLine(posAlongLine / lineLen);\n          var arrowTail = getCoordsAlongLine((posAlongLine - arrowLength) / lineLen);\n          var arrowTailVertex = getCoordsAlongLine((posAlongLine - arrowLength * (1 - ARROW_VLEN_RATIO)) / lineLen);\n          var arrowTailAngle = Math.atan2(arrowHead.y - arrowTail.y, arrowHead.x - arrowTail.x) - Math.PI / 2;\n          ctx.beginPath();\n          ctx.moveTo(arrowHead.x, arrowHead.y);\n          ctx.lineTo(arrowTail.x + arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y + arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.lineTo(arrowTailVertex.x, arrowTailVertex.y);\n          ctx.lineTo(arrowTail.x - arrowHalfWidth * Math.cos(arrowTailAngle), arrowTail.y - arrowHalfWidth * Math.sin(arrowTailAngle));\n          ctx.fillStyle = arrowColor;\n          ctx.fill();\n        });\n        ctx.restore();\n      }\n      function paintPhotons() {\n        var getNumPhotons = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticles);\n        var getSpeed = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleSpeed);\n        var getOffset = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleOffset);\n        var getDiameter = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleWidth);\n        var getVisibility = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkVisibility);\n        var getColor = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkDirectionalParticleColor || state.linkColor);\n        var ctx = state.ctx;\n        ctx.save();\n        state.graphData.links.filter(getVisibility).forEach(function (link) {\n          var numCyclePhotons = getNumPhotons(link);\n          if (!link.hasOwnProperty('__photons') || !link.__photons.length) return;\n          var start = link.source;\n          var end = link.target;\n          if (!start || !end || !start.hasOwnProperty('x') || !end.hasOwnProperty('x')) return; // skip invalid link\n\n          var particleSpeed = getSpeed(link);\n          var particleOffset = Math.abs(getOffset(link));\n          var photons = link.__photons || [];\n          var photonR = Math.max(0, getDiameter(link) / 2) / Math.sqrt(state.globalScale);\n          var photonColor = getColor(link) || 'rgba(0,0,0,0.28)';\n          ctx.fillStyle = photonColor;\n\n          // Construct bezier for curved lines\n          var bzLine = link.__controlPoints ? _construct(bezier_js__WEBPACK_IMPORTED_MODULE_4__.Bezier, [start.x, start.y].concat(_toConsumableArray(link.__controlPoints), [end.x, end.y])) : null;\n          var cyclePhotonIdx = 0;\n          var needsCleanup = false; // whether some photons need to be removed from list\n          photons.forEach(function (photon) {\n            var singleHop = !!photon.__singleHop;\n            if (!photon.hasOwnProperty('__progressRatio')) {\n              photon.__progressRatio = singleHop ? 0 : (cyclePhotonIdx + particleOffset) / numCyclePhotons;\n            }\n            !singleHop && cyclePhotonIdx++; // increase regular photon index\n\n            photon.__progressRatio += particleSpeed;\n            if (photon.__progressRatio >= 1) {\n              if (!singleHop) {\n                photon.__progressRatio = photon.__progressRatio % 1;\n              } else {\n                needsCleanup = true;\n                return;\n              }\n            }\n            var photonPosRatio = photon.__progressRatio;\n            var coords = bzLine ? bzLine.get(photonPosRatio) // get position along bezier line\n            : {\n              // straight line: interpolate linearly\n              x: start.x + (end.x - start.x) * photonPosRatio || 0,\n              y: start.y + (end.y - start.y) * photonPosRatio || 0\n            };\n            if (state.linkDirectionalParticleCanvasObject) {\n              state.linkDirectionalParticleCanvasObject(coords.x, coords.y, link, ctx, state.globalScale);\n            } else {\n              ctx.beginPath();\n              ctx.arc(coords.x, coords.y, photonR, 0, 2 * Math.PI, false);\n              ctx.fill();\n            }\n          });\n          if (needsCleanup) {\n            // remove expired single hop photons\n            link.__photons = link.__photons.filter(function (photon) {\n              return !photon.__singleHop || photon.__progressRatio <= 1;\n            });\n          }\n        });\n        ctx.restore();\n      }\n    },\n    emitParticle: function emitParticle(state, link) {\n      if (link) {\n        !link.__photons && (link.__photons = []);\n        link.__photons.push({\n          __singleHop: true\n        }); // add a single hop particle\n      }\n      return this;\n    }\n  },\n  stateInit: function stateInit() {\n    return {\n      forceLayout: (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_9__[\"default\"])().force('link', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_10__[\"default\"])()).force('charge', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_11__[\"default\"])()).force('center', (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_12__[\"default\"])()).force('dagRadial', null).stop(),\n      engineRunning: false\n    };\n  },\n  init: function init(canvasCtx, state) {\n    // Main canvas object to manipulate\n    state.ctx = canvasCtx;\n  },\n  update: function update(state, changedProps) {\n    state.engineRunning = false; // Pause simulation\n    state.onUpdate();\n    if (state.nodeAutoColorBy !== null) {\n      // Auto add color to uncolored nodes\n      autoColorObjects(state.graphData.nodes, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeAutoColorBy), state.nodeColor);\n    }\n    if (state.linkAutoColorBy !== null) {\n      // Auto add color to uncolored links\n      autoColorObjects(state.graphData.links, (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkAutoColorBy), state.linkColor);\n    }\n\n    // parse links\n    state.graphData.links.forEach(function (link) {\n      link.source = link[state.linkSource];\n      link.target = link[state.linkTarget];\n    });\n\n    // Feed data to force-directed layout\n    state.forceLayout.stop().alpha(1) // re-heat the simulation\n    .nodes(state.graphData.nodes);\n\n    // add links (if link force is still active)\n    var linkForce = state.forceLayout.force('link');\n    if (linkForce) {\n      linkForce.id(function (d) {\n        return d[state.nodeId];\n      }).links(state.graphData.links);\n    }\n\n    // setup dag force constraints\n    var nodeDepths = state.dagMode && getDagDepths(state.graphData, function (node) {\n      return node[state.nodeId];\n    }, {\n      nodeFilter: state.dagNodeFilter,\n      onLoopError: state.onDagError || undefined\n    });\n    var maxDepth = Math.max.apply(Math, _toConsumableArray(Object.values(nodeDepths || [])));\n    var dagLevelDistance = state.dagLevelDistance || state.graphData.nodes.length / (maxDepth || 1) * DAG_LEVEL_NODE_RATIO * (['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? 0.7 : 1);\n\n    // Reset relevant fx/fy when swapping dag modes\n    if (['lr', 'rl', 'td', 'bu'].includes(changedProps.dagMode)) {\n      var resetProp = ['lr', 'rl'].includes(changedProps.dagMode) ? 'fx' : 'fy';\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        return delete node[resetProp];\n      });\n    }\n\n    // Fix nodes to x,y for dag mode\n    if (['lr', 'rl', 'td', 'bu'].includes(state.dagMode)) {\n      var invert = ['rl', 'bu'].includes(state.dagMode);\n      var fixFn = function fixFn(node) {\n        return (nodeDepths[node[state.nodeId]] - maxDepth / 2) * dagLevelDistance * (invert ? -1 : 1);\n      };\n      var _resetProp = ['lr', 'rl'].includes(state.dagMode) ? 'fx' : 'fy';\n      state.graphData.nodes.filter(state.dagNodeFilter).forEach(function (node) {\n        return node[_resetProp] = fixFn(node);\n      });\n    }\n\n    // Use radial force for radial dags\n    state.forceLayout.force('dagRadial', ['radialin', 'radialout'].indexOf(state.dagMode) !== -1 ? (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_13__[\"default\"])(function (node) {\n      var nodeDepth = nodeDepths[node[state.nodeId]] || -1;\n      return (state.dagMode === 'radialin' ? maxDepth - nodeDepth : nodeDepth) * dagLevelDistance;\n    }).strength(function (node) {\n      return state.dagNodeFilter(node) ? 1 : 0;\n    }) : null);\n    for (var i = 0; i < state.warmupTicks && !(state.d3AlphaMin > 0 && state.forceLayout.alpha() < state.d3AlphaMin); i++) {\n      state.forceLayout.tick();\n    } // Initial ticks before starting to render\n\n    this.resetCountdown();\n    state.onFinishUpdate();\n  }\n});\n\nfunction linkKapsule (kapsulePropNames, kapsuleType) {\n  var propNames = kapsulePropNames instanceof Array ? kapsulePropNames : [kapsulePropNames];\n  var dummyK = new kapsuleType(); // To extract defaults\n  dummyK._destructor && dummyK._destructor();\n  return {\n    linkProp: function linkProp(prop) {\n      // link property config\n      return {\n        \"default\": dummyK[prop](),\n        onChange: function onChange(v, state) {\n          propNames.forEach(function (propName) {\n            return state[propName][prop](v);\n          });\n        },\n        triggerUpdate: false\n      };\n    },\n    linkMethod: function linkMethod(method) {\n      // link method pass-through\n      return function (state) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        var returnVals = [];\n        propNames.forEach(function (propName) {\n          var kapsuleInstance = state[propName];\n          var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);\n          if (returnVal !== kapsuleInstance) {\n            returnVals.push(returnVal);\n          }\n        });\n        return returnVals.length ? returnVals[0] : this; // chain based on the parent object, not the inner kapsule\n      };\n    }\n  };\n}\n\nvar HOVER_CANVAS_THROTTLE_DELAY = 800; // ms to throttle shadow canvas updates for perf improvement\nvar ZOOM2NODES_FACTOR = 4;\nvar DRAG_CLICK_TOLERANCE_PX = 5; // How many px can a node be accidentally dragged before disabling the click\n\n// Expose config from forceGraph\nvar bindFG = linkKapsule('forceGraph', CanvasForceGraph);\nvar bindBoth = linkKapsule(['forceGraph', 'shadowGraph'], CanvasForceGraph);\nvar linkedProps = Object.assign.apply(Object, _toConsumableArray(['nodeColor', 'nodeAutoColorBy', 'nodeCanvasObject', 'nodeCanvasObjectMode', 'linkColor', 'linkAutoColorBy', 'linkLineDash', 'linkWidth', 'linkCanvasObject', 'linkCanvasObjectMode', 'linkDirectionalArrowLength', 'linkDirectionalArrowColor', 'linkDirectionalArrowRelPos', 'linkDirectionalParticles', 'linkDirectionalParticleSpeed', 'linkDirectionalParticleOffset', 'linkDirectionalParticleWidth', 'linkDirectionalParticleColor', 'linkDirectionalParticleCanvasObject', 'dagMode', 'dagLevelDistance', 'dagNodeFilter', 'onDagError', 'd3AlphaMin', 'd3AlphaDecay', 'd3VelocityDecay', 'warmupTicks', 'cooldownTicks', 'cooldownTime', 'onEngineTick', 'onEngineStop'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkProp(p));\n})).concat(_toConsumableArray(['nodeRelSize', 'nodeId', 'nodeVal', 'nodeVisibility', 'linkSource', 'linkTarget', 'linkVisibility', 'linkCurvature'].map(function (p) {\n  return _defineProperty({}, p, bindBoth.linkProp(p));\n}))));\nvar linkedMethods = Object.assign.apply(Object, _toConsumableArray(['d3Force', 'd3ReheatSimulation', 'emitParticle'].map(function (p) {\n  return _defineProperty({}, p, bindFG.linkMethod(p));\n})));\nfunction adjustCanvasSize(state) {\n  if (state.canvas) {\n    var curWidth = state.canvas.width;\n    var curHeight = state.canvas.height;\n    if (curWidth === 300 && curHeight === 150) {\n      // Default canvas dimensions\n      curWidth = curHeight = 0;\n    }\n    var pxScale = window.devicePixelRatio; // 2 on retina displays\n    curWidth /= pxScale;\n    curHeight /= pxScale;\n\n    // Resize canvases\n    [state.canvas, state.shadowCanvas].forEach(function (canvas) {\n      // Element size\n      canvas.style.width = \"\".concat(state.width, \"px\");\n      canvas.style.height = \"\".concat(state.height, \"px\");\n\n      // Memory size (scaled to avoid blurriness)\n      canvas.width = state.width * pxScale;\n      canvas.height = state.height * pxScale;\n\n      // Normalize coordinate system to use css pixels (on init only)\n      if (!curWidth && !curHeight) {\n        canvas.getContext('2d').scale(pxScale, pxScale);\n      }\n    });\n\n    // Relative center panning based on 0,0\n    var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n    state.zoom.translateBy(state.zoom.__baseElem, (state.width - curWidth) / 2 / k, (state.height - curHeight) / 2 / k);\n    state.needsRedraw = true;\n  }\n}\nfunction resetTransform(ctx) {\n  var pxRatio = window.devicePixelRatio;\n  ctx.setTransform(pxRatio, 0, 0, pxRatio, 0, 0);\n}\nfunction clearCanvas(ctx, width, height) {\n  ctx.save();\n  resetTransform(ctx); // reset transform\n  ctx.clearRect(0, 0, width, height);\n  ctx.restore(); //restore transforms\n}\n\n//\n\nvar forceGraph = (0,kapsule__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n  props: _objectSpread2({\n    width: {\n      \"default\": window.innerWidth,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    height: {\n      \"default\": window.innerHeight,\n      onChange: function onChange(_, state) {\n        return adjustCanvasSize(state);\n      },\n      triggerUpdate: false\n    },\n    graphData: {\n      \"default\": {\n        nodes: [],\n        links: []\n      },\n      onChange: function onChange(d, state) {\n        // Wipe color registry if all objects are new\n        [d.nodes, d.links].every(function (arr) {\n          return (arr || []).every(function (d) {\n            return !d.hasOwnProperty('__indexColor');\n          });\n        }) && state.colorTracker.reset();\n        [{\n          type: 'Node',\n          objs: d.nodes\n        }, {\n          type: 'Link',\n          objs: d.links\n        }].forEach(hexIndex);\n        state.forceGraph.graphData(d);\n        state.shadowGraph.graphData(d);\n        function hexIndex(_ref4) {\n          var type = _ref4.type,\n            objs = _ref4.objs;\n          objs.filter(function (d) {\n            if (!d.hasOwnProperty('__indexColor')) return true;\n            var cur = state.colorTracker.lookup(d.__indexColor);\n            return !cur || !cur.hasOwnProperty('d') || cur.d !== d;\n          }).forEach(function (d) {\n            // store object lookup color\n            d.__indexColor = state.colorTracker.register({\n              type: type,\n              d: d\n            });\n          });\n        }\n      },\n      triggerUpdate: false\n    },\n    backgroundColor: {\n      onChange: function onChange(color, state) {\n        state.canvas && color && (state.canvas.style.background = color);\n      },\n      triggerUpdate: false\n    },\n    nodeLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    nodePointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.nodeCanvasObject(!paintFn ? null : function (node, ctx, globalScale) {\n          return paintFn(node, node.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkPointerAreaPaint: {\n      onChange: function onChange(paintFn, state) {\n        state.shadowGraph.linkCanvasObject(!paintFn ? null : function (link, ctx, globalScale) {\n          return paintFn(link, link.__indexColor, ctx, globalScale);\n        });\n        state.flushShadowCanvas && state.flushShadowCanvas();\n      },\n      triggerUpdate: false\n    },\n    linkLabel: {\n      \"default\": 'name',\n      triggerUpdate: false\n    },\n    linkHoverPrecision: {\n      \"default\": 4,\n      triggerUpdate: false\n    },\n    minZoom: {\n      \"default\": 0.01,\n      onChange: function onChange(minZoom, state) {\n        state.zoom.scaleExtent([minZoom, state.zoom.scaleExtent()[1]]);\n      },\n      triggerUpdate: false\n    },\n    maxZoom: {\n      \"default\": 1000,\n      onChange: function onChange(maxZoom, state) {\n        state.zoom.scaleExtent([state.zoom.scaleExtent()[0], maxZoom]);\n      },\n      triggerUpdate: false\n    },\n    enableNodeDrag: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enablePanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    enableZoomPanInteraction: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    // to be deprecated\n    enablePointerInteraction: {\n      \"default\": true,\n      onChange: function onChange(_, state) {\n        state.hoverObj = null;\n      },\n      triggerUpdate: false\n    },\n    autoPauseRedraw: {\n      \"default\": true,\n      triggerUpdate: false\n    },\n    onNodeDrag: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeDragEnd: {\n      \"default\": function _default() {},\n      triggerUpdate: false\n    },\n    onNodeClick: {\n      triggerUpdate: false\n    },\n    onNodeRightClick: {\n      triggerUpdate: false\n    },\n    onNodeHover: {\n      triggerUpdate: false\n    },\n    onLinkClick: {\n      triggerUpdate: false\n    },\n    onLinkRightClick: {\n      triggerUpdate: false\n    },\n    onLinkHover: {\n      triggerUpdate: false\n    },\n    onBackgroundClick: {\n      triggerUpdate: false\n    },\n    onBackgroundRightClick: {\n      triggerUpdate: false\n    },\n    onZoom: {\n      triggerUpdate: false\n    },\n    onZoomEnd: {\n      triggerUpdate: false\n    },\n    onRenderFramePre: {\n      triggerUpdate: false\n    },\n    onRenderFramePost: {\n      triggerUpdate: false\n    }\n  }, linkedProps),\n  aliases: {\n    // Prop names supported for backwards compatibility\n    stopAnimation: 'pauseAnimation'\n  },\n  methods: _objectSpread2({\n    graph2ScreenCoords: function graph2ScreenCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: x * t.k + t.x,\n        y: y * t.k + t.y\n      };\n    },\n    screen2GraphCoords: function screen2GraphCoords(state, x, y) {\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      return {\n        x: (x - t.x) / t.k,\n        y: (y - t.y) / t.k\n      };\n    },\n    centerAt: function centerAt(state, x, y, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (x !== undefined || y !== undefined) {\n        var finalPos = Object.assign({}, x !== undefined ? {\n          x: x\n        } : {}, y !== undefined ? {\n          y: y\n        } : {});\n        if (!transitionDuration) {\n          // no animation\n          setCenter(finalPos);\n        } else {\n          state.tweenGroup.add(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween(getCenter()).to(finalPos, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(setCenter).start());\n        }\n        return this;\n      }\n\n      // getter\n      return getCenter();\n\n      //\n\n      function getCenter() {\n        var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n        return {\n          x: (state.width / 2 - t.x) / t.k,\n          y: (state.height / 2 - t.y) / t.k\n        };\n      }\n      function setCenter(_ref5) {\n        var x = _ref5.x,\n          y = _ref5.y;\n        state.zoom.translateTo(state.zoom.__baseElem, x === undefined ? getCenter().x : x, y === undefined ? getCenter().y : y);\n        state.needsRedraw = true;\n      }\n    },\n    zoom: function zoom(state, k, transitionDuration) {\n      if (!state.canvas) return null; // no canvas yet\n\n      // setter\n      if (k !== undefined) {\n        if (!transitionDuration) {\n          // no animation\n          setZoom(k);\n        } else {\n          state.tweenGroup.add(new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Tween({\n            k: getZoom()\n          }).to({\n            k: k\n          }, transitionDuration).easing(_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Easing.Quadratic.Out).onUpdate(function (_ref6) {\n            var k = _ref6.k;\n            return setZoom(k);\n          }).start());\n        }\n        return this;\n      }\n\n      // getter\n      return getZoom();\n\n      //\n\n      function getZoom() {\n        return (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      }\n      function setZoom(k) {\n        state.zoom.scaleTo(state.zoom.__baseElem, k);\n        state.needsRedraw = true;\n      }\n    },\n    zoomToFit: function zoomToFit(state) {\n      var transitionDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n      for (var _len = arguments.length, bboxArgs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        bboxArgs[_key - 3] = arguments[_key];\n      }\n      var bbox = this.getGraphBbox.apply(this, bboxArgs);\n      if (bbox) {\n        var center = {\n          x: (bbox.x[0] + bbox.x[1]) / 2,\n          y: (bbox.y[0] + bbox.y[1]) / 2\n        };\n        var zoomK = Math.max(1e-12, Math.min(1e12, (state.width - padding * 2) / (bbox.x[1] - bbox.x[0]), (state.height - padding * 2) / (bbox.y[1] - bbox.y[0])));\n        this.centerAt(center.x, center.y, transitionDuration);\n        this.zoom(zoomK, transitionDuration);\n      }\n      return this;\n    },\n    getGraphBbox: function getGraphBbox(state) {\n      var nodeFilter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      var getVal = (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.nodeVal);\n      var getR = function getR(node) {\n        return Math.sqrt(Math.max(0, getVal(node) || 1)) * state.nodeRelSize;\n      };\n      var nodesPos = state.graphData.nodes.filter(nodeFilter).map(function (node) {\n        return {\n          x: node.x,\n          y: node.y,\n          r: getR(node)\n        };\n      });\n      return !nodesPos.length ? null : {\n        x: [(0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.x - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(nodesPos, function (node) {\n          return node.x + node.r;\n        })],\n        y: [(0,d3_array__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(nodesPos, function (node) {\n          return node.y - node.r;\n        }), (0,d3_array__WEBPACK_IMPORTED_MODULE_15__[\"default\"])(nodesPos, function (node) {\n          return node.y + node.r;\n        })]\n      };\n    },\n    pauseAnimation: function pauseAnimation(state) {\n      if (state.animationFrameRequestId) {\n        cancelAnimationFrame(state.animationFrameRequestId);\n        state.animationFrameRequestId = null;\n      }\n      return this;\n    },\n    resumeAnimation: function resumeAnimation(state) {\n      if (!state.animationFrameRequestId) {\n        this._animationCycle();\n      }\n      return this;\n    },\n    _destructor: function _destructor() {\n      this.pauseAnimation();\n      this.graphData({\n        nodes: [],\n        links: []\n      });\n    }\n  }, linkedMethods),\n  stateInit: function stateInit() {\n    return {\n      lastSetZoom: 1,\n      zoom: (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)(),\n      forceGraph: new CanvasForceGraph(),\n      shadowGraph: new CanvasForceGraph().cooldownTicks(0).nodeColor('__indexColor').linkColor('__indexColor').isShadow(true),\n      colorTracker: new canvas_color_tracker__WEBPACK_IMPORTED_MODULE_16__[\"default\"](),\n      // indexed objects for rgb lookup\n      tweenGroup: new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_1__.Group()\n    };\n  },\n  init: function init(domNode, state) {\n    var _this = this;\n    // Wipe DOM\n    domNode.innerHTML = '';\n\n    // Container anchor for canvas and tooltip\n    var container = document.createElement('div');\n    container.classList.add('force-graph-container');\n    container.style.position = 'relative';\n    domNode.appendChild(container);\n    state.canvas = document.createElement('canvas');\n    if (state.backgroundColor) state.canvas.style.background = state.backgroundColor;\n    container.appendChild(state.canvas);\n    state.shadowCanvas = document.createElement('canvas');\n\n    // Show shadow canvas\n    //state.shadowCanvas.style.position = 'absolute';\n    //state.shadowCanvas.style.top = '0';\n    //state.shadowCanvas.style.left = '0';\n    //container.appendChild(state.shadowCanvas);\n\n    var ctx = state.canvas.getContext('2d');\n    var shadowCtx = state.shadowCanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    var pointerPos = {\n      x: -1e12,\n      y: -1e12\n    };\n    var getObjUnderPointer = function getObjUnderPointer() {\n      var obj = null;\n      var pxScale = window.devicePixelRatio;\n      var px = pointerPos.x > 0 && pointerPos.y > 0 ? shadowCtx.getImageData(pointerPos.x * pxScale, pointerPos.y * pxScale, 1, 1) : null;\n      // Lookup object per pixel color\n      px && (obj = state.colorTracker.lookup(px.data));\n      return obj;\n    };\n\n    // Setup node drag interaction\n    (0,d3_selection__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(state.canvas).call((0,d3_drag__WEBPACK_IMPORTED_MODULE_18__[\"default\"])().subject(function () {\n      if (!state.enableNodeDrag) {\n        return null;\n      }\n      var obj = getObjUnderPointer();\n      return obj && obj.type === 'Node' ? obj.d : null; // Only drag nodes\n    }).on('start', function (ev) {\n      var obj = ev.subject;\n      obj.__initialDragPos = {\n        x: obj.x,\n        y: obj.y,\n        fx: obj.fx,\n        fy: obj.fy\n      };\n\n      // keep engine running at low intensity throughout drag\n      if (!ev.active) {\n        obj.fx = obj.x;\n        obj.fy = obj.y; // Fix points\n      }\n\n      // drag cursor\n      state.canvas.classList.add('grabbable');\n    }).on('drag', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var dragPos = ev;\n      var k = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n      var translate = {\n        x: initPos.x + (dragPos.x - initPos.x) / k - obj.x,\n        y: initPos.y + (dragPos.y - initPos.y) / k - obj.y\n      };\n\n      // Move fx/fy (and x/y) of nodes based on the scaled drag distance since the drag start\n      ['x', 'y'].forEach(function (c) {\n        return obj[\"f\".concat(c)] = obj[c] = initPos[c] + (dragPos[c] - initPos[c]) / k;\n      });\n\n      // Only engage full drag if distance reaches above threshold\n      if (!obj.__dragged && DRAG_CLICK_TOLERANCE_PX >= Math.sqrt((0,d3_array__WEBPACK_IMPORTED_MODULE_19__[\"default\"])(['x', 'y'].map(function (k) {\n        return Math.pow(ev[k] - initPos[k], 2);\n      })))) return;\n      state.forceGraph.d3AlphaTarget(0.3) // keep engine running at low intensity throughout drag\n      .resetCountdown(); // prevent freeze while dragging\n\n      state.isPointerDragging = true;\n      obj.__dragged = true;\n      state.onNodeDrag(obj, translate);\n    }).on('end', function (ev) {\n      var obj = ev.subject;\n      var initPos = obj.__initialDragPos;\n      var translate = {\n        x: obj.x - initPos.x,\n        y: obj.y - initPos.y\n      };\n      if (initPos.fx === undefined) {\n        obj.fx = undefined;\n      }\n      if (initPos.fy === undefined) {\n        obj.fy = undefined;\n      }\n      delete obj.__initialDragPos;\n      if (state.forceGraph.d3AlphaTarget()) {\n        state.forceGraph.d3AlphaTarget(0) // release engine low intensity\n        .resetCountdown(); // let the engine readjust after releasing fixed nodes\n      }\n\n      // drag cursor\n      state.canvas.classList.remove('grabbable');\n      state.isPointerDragging = false;\n      if (obj.__dragged) {\n        delete obj.__dragged;\n        state.onNodeDragEnd(obj, translate);\n      }\n    }));\n\n    // Setup zoom / pan interaction\n    state.zoom(state.zoom.__baseElem = (0,d3_selection__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(state.canvas)); // Attach controlling elem for easy access\n\n    state.zoom.__baseElem.on('dblclick.zoom', null); // Disable double-click to zoom\n\n    state.zoom.filter(function (ev) {\n      return (\n        // disable zoom interaction\n        !ev.button && state.enableZoomPanInteraction && (ev.type !== 'wheel' || (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.enableZoomInteraction)(ev)) && (ev.type === 'wheel' || (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.enablePanInteraction)(ev))\n      );\n    }).on('zoom', function (ev) {\n      var t = ev.transform;\n      [ctx, shadowCtx].forEach(function (c) {\n        resetTransform(c);\n        c.translate(t.x, t.y);\n        c.scale(t.k, t.k);\n      });\n      state.isPointerDragging = true;\n      state.onZoom && state.onZoom(_objectSpread2(_objectSpread2({}, t), _this.centerAt())); // report x,y coordinates relative to canvas center\n      state.needsRedraw = true;\n    }).on('end', function (ev) {\n      state.isPointerDragging = false;\n      state.onZoomEnd && state.onZoomEnd(_objectSpread2(_objectSpread2({}, ev.transform), _this.centerAt()));\n    });\n    adjustCanvasSize(state);\n    state.forceGraph.onNeedsRedraw(function () {\n      return state.needsRedraw = true;\n    }).onFinishUpdate(function () {\n      // re-zoom, if still in default position (not user modified)\n      if ((0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k === state.lastSetZoom && state.graphData.nodes.length) {\n        state.zoom.scaleTo(state.zoom.__baseElem, state.lastSetZoom = ZOOM2NODES_FACTOR / Math.cbrt(state.graphData.nodes.length));\n        state.needsRedraw = true;\n      }\n    });\n\n    // Setup tooltip\n    state.tooltip = new float_tooltip__WEBPACK_IMPORTED_MODULE_3__[\"default\"](container);\n\n    // Capture pointer coords on move or touchstart\n    ['pointermove', 'pointerdown'].forEach(function (evType) {\n      return container.addEventListener(evType, function (ev) {\n        if (evType === 'pointerdown') {\n          state.isPointerPressed = true; // track click state\n          state.pointerDownEvent = ev;\n        }\n\n        // detect pointer drag on canvas pan\n        !state.isPointerDragging && ev.type === 'pointermove' && state.onBackgroundClick // only bother detecting drags this way if background clicks are enabled (so they don't trigger accidentally on canvas panning)\n        && (ev.pressure > 0 || state.isPointerPressed) // ev.pressure always 0 on Safari, so we use the isPointerPressed tracker\n        && (ev.pointerType === 'mouse' || ev.movementX === undefined || [ev.movementX, ev.movementY].some(function (m) {\n          return Math.abs(m) > 1;\n        })) // relax drag trigger sensitivity on non-mouse (touch/pen) events\n        && (state.isPointerDragging = true);\n\n        // update the pointer pos\n        var offset = getOffset(container);\n        pointerPos.x = ev.pageX - offset.left;\n        pointerPos.y = ev.pageY - offset.top;\n\n        //\n\n        function getOffset(el) {\n          var rect = el.getBoundingClientRect(),\n            scrollLeft = window.pageXOffset || document.documentElement.scrollLeft,\n            scrollTop = window.pageYOffset || document.documentElement.scrollTop;\n          return {\n            top: rect.top + scrollTop,\n            left: rect.left + scrollLeft\n          };\n        }\n      }, {\n        passive: true\n      });\n    });\n\n    // Handle click/touch events on nodes/links\n    container.addEventListener('pointerup', function (ev) {\n      if (!state.isPointerPressed) {\n        return; // don't trigger click events if pointer is not pressed on the canvas\n      }\n      state.isPointerPressed = false;\n      if (state.isPointerDragging) {\n        state.isPointerDragging = false;\n        return; // don't trigger click events after pointer drag (pan / node drag functionality)\n      }\n      var cbEvents = [ev, state.pointerDownEvent];\n      requestAnimationFrame(function () {\n        // trigger click events asynchronously, to allow hoverObj to be set (on frame)\n        if (ev.button === 0) {\n          // mouse left-click or touch\n          if (state.hoverObj) {\n            var fn = state[\"on\".concat(state.hoverObj.type, \"Click\")];\n            fn && fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundClick && state.onBackgroundClick.apply(state, cbEvents);\n          }\n        }\n        if (ev.button === 2) {\n          // mouse right-click\n          if (state.hoverObj) {\n            var _fn = state[\"on\".concat(state.hoverObj.type, \"RightClick\")];\n            _fn && _fn.apply(void 0, [state.hoverObj.d].concat(cbEvents));\n          } else {\n            state.onBackgroundRightClick && state.onBackgroundRightClick.apply(state, cbEvents);\n          }\n        }\n      });\n    }, {\n      passive: true\n    });\n    container.addEventListener('contextmenu', function (ev) {\n      if (!state.onBackgroundRightClick && !state.onNodeRightClick && !state.onLinkRightClick) return true; // default contextmenu behavior\n      ev.preventDefault();\n      return false;\n    });\n    state.forceGraph(ctx);\n    state.shadowGraph(shadowCtx);\n\n    //\n\n    var refreshShadowCanvas = (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(function () {\n      // wipe canvas\n      clearCanvas(shadowCtx, state.width, state.height);\n\n      // Adjust link hover area\n      state.shadowGraph.linkWidth(function (l) {\n        return (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.linkWidth)(l) + state.linkHoverPrecision;\n      });\n\n      // redraw\n      var t = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas);\n      state.shadowGraph.globalScale(t.k).tickFrame();\n    }, HOVER_CANVAS_THROTTLE_DELAY);\n    state.flushShadowCanvas = refreshShadowCanvas.flush; // hook to immediately invoke shadow canvas paint\n\n    // Kick-off renderer\n    (this._animationCycle = function animate() {\n      // IIFE\n      var doRedraw = !state.autoPauseRedraw || !!state.needsRedraw || state.forceGraph.isEngineRunning() || state.graphData.links.some(function (d) {\n        return d.__photons && d.__photons.length;\n      });\n      state.needsRedraw = false;\n      if (state.enablePointerInteraction) {\n        // Update tooltip and trigger onHover events\n        var obj = !state.isPointerDragging ? getObjUnderPointer() : null; // don't hover during drag\n        if (obj !== state.hoverObj) {\n          var prevObj = state.hoverObj;\n          var prevObjType = prevObj ? prevObj.type : null;\n          var objType = obj ? obj.type : null;\n          if (prevObjType && prevObjType !== objType) {\n            // Hover out\n            var fn = state[\"on\".concat(prevObjType, \"Hover\")];\n            fn && fn(null, prevObj.d);\n          }\n          if (objType) {\n            // Hover in\n            var _fn2 = state[\"on\".concat(objType, \"Hover\")];\n            _fn2 && _fn2(obj.d, prevObjType === objType ? prevObj.d : null);\n          }\n          state.tooltip.content(obj ? (0,accessor_fn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state[\"\".concat(obj.type.toLowerCase(), \"Label\")])(obj.d) || null : null);\n\n          // set pointer if hovered object is clickable\n          state.canvas.classList[obj && state[\"on\".concat(objType, \"Click\")] || !obj && state.onBackgroundClick ? 'add' : 'remove']('clickable');\n          state.hoverObj = obj;\n        }\n        doRedraw && refreshShadowCanvas();\n      }\n      if (doRedraw) {\n        // Wipe canvas\n        clearCanvas(ctx, state.width, state.height);\n\n        // Frame cycle\n        var globalScale = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(state.canvas).k;\n        state.onRenderFramePre && state.onRenderFramePre(ctx, globalScale);\n        state.forceGraph.globalScale(globalScale).tickFrame();\n        state.onRenderFramePost && state.onRenderFramePost(ctx, globalScale);\n      }\n      state.tweenGroup.update(); // update canvas animation tweens\n\n      state.animationFrameRequestId = requestAnimationFrame(animate);\n    })();\n  },\n  update: function updateFn(state) {}\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZm9yY2UtZ3JhcGgvZGlzdC9mb3JjZS1ncmFwaC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzQztBQUNRO0FBQ2Y7QUFDVTtBQUNKO0FBQ29CO0FBQzNCO0FBQ087QUFDVztBQUNaO0FBQzhEO0FBQy9EO0FBQ0U7QUFDRztBQUNVOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLG1CQUFtQixzQkFBc0Isa0JBQWtCLDZDQUE2QyxHQUFHLHVDQUF1QyxvQkFBb0IsR0FBRyx1Q0FBdUMsaUJBQWlCLGlCQUFpQixzQkFBc0IseUJBQXlCLEdBQUcsOENBQThDLHFCQUFxQiwwQkFBMEIsNkJBQTZCLEdBQUc7QUFDaGQ7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVksa0VBQWtFO0FBQzdILE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsWUFBWTtBQUNaLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtB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QUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsY0FBYyxzREFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWMsc0RBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxVQUFVLElBQUk7QUFDZDtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixtQ0FBbUMsb0RBQUssc0RBQXNELHFEQUFN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LGlDQUFpQzs7QUFFakM7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Acmhpei93ZWIvLi9ub2RlX21vZHVsZXMvZm9yY2UtZ3JhcGgvZGlzdC9mb3JjZS1ncmFwaC5tanM/ZjRiYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZWxlY3QgfSBmcm9tICdkMy1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgem9vbVRyYW5zZm9ybSwgem9vbSB9IGZyb20gJ2QzLXpvb20nO1xuaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgc3VtLCBtaW4sIG1heCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IEdyb3VwLCBUd2VlbiwgRWFzaW5nIH0gZnJvbSAnQHR3ZWVuanMvdHdlZW4uanMnO1xuaW1wb3J0IEthcHN1bGUgZnJvbSAna2Fwc3VsZSc7XG5pbXBvcnQgYWNjZXNzb3JGbiBmcm9tICdhY2Nlc3Nvci1mbic7XG5pbXBvcnQgQ29sb3JUcmFja2VyIGZyb20gJ2NhbnZhcy1jb2xvci10cmFja2VyJztcbmltcG9ydCBUb29sdGlwIGZyb20gJ2Zsb2F0LXRvb2x0aXAnO1xuaW1wb3J0IHsgZm9yY2VSYWRpYWwsIGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VMaW5rLCBmb3JjZU1hbnlCb2R5LCBmb3JjZUNlbnRlciB9IGZyb20gJ2QzLWZvcmNlLTNkJztcbmltcG9ydCB7IEJlemllciB9IGZyb20gJ2Jlemllci1qcyc7XG5pbXBvcnQgaW5kZXhCeSBmcm9tICdpbmRleC1hcnJheS1ieSc7XG5pbXBvcnQgeyBzY2FsZU9yZGluYWwgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgeyBzY2hlbWVQYWlyZWQgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnO1xuXG5mdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAocmVmID09PSB2b2lkIDApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIuZm9yY2UtZ3JhcGgtY29udGFpbmVyIGNhbnZhcyB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcblxcbi5mb3JjZS1ncmFwaC1jb250YWluZXIgLmNsaWNrYWJsZSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5mb3JjZS1ncmFwaC1jb250YWluZXIgLmdyYWJiYWJsZSB7XFxuICBjdXJzb3I6IG1vdmU7XFxuICBjdXJzb3I6IGdyYWI7XFxuICBjdXJzb3I6IC1tb3otZ3JhYjtcXG4gIGN1cnNvcjogLXdlYmtpdC1ncmFiO1xcbn1cXG5cXG4uZm9yY2UtZ3JhcGgtY29udGFpbmVyIC5ncmFiYmFibGU6YWN0aXZlIHtcXG4gIGN1cnNvcjogZ3JhYmJpbmc7XFxuICBjdXJzb3I6IC1tb3otZ3JhYmJpbmc7XFxuICBjdXJzb3I6IC13ZWJraXQtZ3JhYmJpbmc7XFxufVxcblwiO1xuc3R5bGVJbmplY3QoY3NzXzI0OHopO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiByO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9jb25zdHJ1Y3QodCwgZSwgcikge1xuICBpZiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpKSByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgdmFyIG8gPSBbbnVsbF07XG4gIG8ucHVzaC5hcHBseShvLCBlKTtcbiAgdmFyIHAgPSBuZXcgKHQuYmluZC5hcHBseSh0LCBvKSkoKTtcbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9IHRydWUsXG4gICAgICBvID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpID0gKHQgPSB0LmNhbGwocikpLm5leHQsIDAgPT09IGwpIDsgZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gdHJ1ZSwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgcik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGEpIHtcbiAgaWYgKHIpIHtcbiAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgcikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpO1xuICAgIHZhciB0ID0ge30udG9TdHJpbmcuY2FsbChyKS5zbGljZSg4LCAtMSk7XG4gICAgcmV0dXJuIFwiT2JqZWN0XCIgPT09IHQgJiYgci5jb25zdHJ1Y3RvciAmJiAodCA9IHIuY29uc3RydWN0b3IubmFtZSksIFwiTWFwXCIgPT09IHQgfHwgXCJTZXRcIiA9PT0gdCA/IEFycmF5LmZyb20ocikgOiBcIkFyZ3VtZW50c1wiID09PSB0IHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KHQpID8gX2FycmF5TGlrZVRvQXJyYXkociwgYSkgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIGF1dG9Db2xvclNjYWxlID0gc2NhbGVPcmRpbmFsKHNjaGVtZVBhaXJlZCk7XG5cbi8vIEF1dG9zZXQgYXR0cmlidXRlIGNvbG9yRmllbGQgYnkgY29sb3JCeUFjY2Vzc29yIHByb3BlcnR5XG4vLyBJZiBhbiBvYmplY3QgaGFzIGFscmVhZHkgYSBjb2xvciwgZG9uJ3Qgc2V0IGl0XG4vLyBPYmplY3RzIGNhbiBiZSBub2RlcyBvciBsaW5rc1xuZnVuY3Rpb24gYXV0b0NvbG9yT2JqZWN0cyhvYmplY3RzLCBjb2xvckJ5QWNjZXNzb3IsIGNvbG9yRmllbGQpIHtcbiAgaWYgKCFjb2xvckJ5QWNjZXNzb3IgfHwgdHlwZW9mIGNvbG9yRmllbGQgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gIG9iamVjdHMuZmlsdGVyKGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gIW9ialtjb2xvckZpZWxkXTtcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgb2JqW2NvbG9yRmllbGRdID0gYXV0b0NvbG9yU2NhbGUoY29sb3JCeUFjY2Vzc29yKG9iaikpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RGFnRGVwdGhzIChfcmVmLCBpZEFjY2Vzc29yKSB7XG4gIHZhciBub2RlcyA9IF9yZWYubm9kZXMsXG4gICAgbGlua3MgPSBfcmVmLmxpbmtzO1xuICB2YXIgX3JlZjIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9LFxuICAgIF9yZWYyJG5vZGVGaWx0ZXIgPSBfcmVmMi5ub2RlRmlsdGVyLFxuICAgIG5vZGVGaWx0ZXIgPSBfcmVmMiRub2RlRmlsdGVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IDogX3JlZjIkbm9kZUZpbHRlcixcbiAgICBfcmVmMiRvbkxvb3BFcnJvciA9IF9yZWYyLm9uTG9vcEVycm9yLFxuICAgIG9uTG9vcEVycm9yID0gX3JlZjIkb25Mb29wRXJyb3IgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChsb29wSWRzKSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgREFHIHN0cnVjdHVyZSEgRm91bmQgY3ljbGUgaW4gbm9kZSBwYXRoOiBcIi5jb25jYXQobG9vcElkcy5qb2luKCcgLT4gJyksIFwiLlwiKTtcbiAgICB9IDogX3JlZjIkb25Mb29wRXJyb3I7XG4gIC8vIGxpbmtlZCBncmFwaFxuICB2YXIgZ3JhcGggPSB7fTtcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBncmFwaFtpZEFjY2Vzc29yKG5vZGUpXSA9IHtcbiAgICAgIGRhdGE6IG5vZGUsXG4gICAgICBvdXQ6IFtdLFxuICAgICAgZGVwdGg6IC0xLFxuICAgICAgc2tpcDogIW5vZGVGaWx0ZXIobm9kZSlcbiAgICB9O1xuICB9KTtcbiAgbGlua3MuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgc291cmNlID0gX3JlZjMuc291cmNlLFxuICAgICAgdGFyZ2V0ID0gX3JlZjMudGFyZ2V0O1xuICAgIHZhciBzb3VyY2VJZCA9IGdldE5vZGVJZChzb3VyY2UpO1xuICAgIHZhciB0YXJnZXRJZCA9IGdldE5vZGVJZCh0YXJnZXQpO1xuICAgIGlmICghZ3JhcGguaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB0aHJvdyBcIk1pc3Npbmcgc291cmNlIG5vZGUgd2l0aCBpZDogXCIuY29uY2F0KHNvdXJjZUlkKTtcbiAgICBpZiAoIWdyYXBoLmhhc093blByb3BlcnR5KHRhcmdldElkKSkgdGhyb3cgXCJNaXNzaW5nIHRhcmdldCBub2RlIHdpdGggaWQ6IFwiLmNvbmNhdCh0YXJnZXRJZCk7XG4gICAgdmFyIHNvdXJjZU5vZGUgPSBncmFwaFtzb3VyY2VJZF07XG4gICAgdmFyIHRhcmdldE5vZGUgPSBncmFwaFt0YXJnZXRJZF07XG4gICAgc291cmNlTm9kZS5vdXQucHVzaCh0YXJnZXROb2RlKTtcbiAgICBmdW5jdGlvbiBnZXROb2RlSWQobm9kZSkge1xuICAgICAgcmV0dXJuIF90eXBlb2Yobm9kZSkgPT09ICdvYmplY3QnID8gaWRBY2Nlc3Nvcihub2RlKSA6IG5vZGU7XG4gICAgfVxuICB9KTtcbiAgdmFyIGZvdW5kTG9vcHMgPSBbXTtcbiAgdHJhdmVyc2UoT2JqZWN0LnZhbHVlcyhncmFwaCkpO1xuICB2YXIgbm9kZURlcHRocyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBbe31dLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmVudHJpZXMoZ3JhcGgpLmZpbHRlcihmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICB2YXIgX3JlZjUgPSBfc2xpY2VkVG9BcnJheShfcmVmNCwgMiksXG4gICAgICBub2RlID0gX3JlZjVbMV07XG4gICAgcmV0dXJuICFub2RlLnNraXA7XG4gIH0pLm1hcChmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICB2YXIgX3JlZjcgPSBfc2xpY2VkVG9BcnJheShfcmVmNiwgMiksXG4gICAgICBpZCA9IF9yZWY3WzBdLFxuICAgICAgbm9kZSA9IF9yZWY3WzFdO1xuICAgIHJldHVybiBfZGVmaW5lUHJvcGVydHkoe30sIGlkLCBub2RlLmRlcHRoKTtcbiAgfSkpKSk7XG4gIHJldHVybiBub2RlRGVwdGhzO1xuICBmdW5jdGlvbiB0cmF2ZXJzZShub2Rlcykge1xuICAgIHZhciBub2RlU3RhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBjdXJyZW50RGVwdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGVTdGFjay5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICB2YXIgbG9vcCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobm9kZVN0YWNrLnNsaWNlKG5vZGVTdGFjay5pbmRleE9mKG5vZGUpKSksIFtub2RlXSkubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGlkQWNjZXNzb3IoZC5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZm91bmRMb29wcy5zb21lKGZ1bmN0aW9uIChmb3VuZExvb3ApIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRMb29wLmxlbmd0aCA9PT0gbG9vcC5sZW5ndGggJiYgZm91bmRMb29wLmV2ZXJ5KGZ1bmN0aW9uIChpZCwgaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gaWQgPT09IGxvb3BbaWR4XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBmb3VuZExvb3BzLnB1c2gobG9vcCk7XG4gICAgICAgICAgb25Mb29wRXJyb3IobG9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDE7IC8vIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudERlcHRoID4gbm9kZS5kZXB0aCkge1xuICAgICAgICAvLyBEb24ndCB1bm5lY2Vzc2FyaWx5IHJldmlzaXQgY2h1bmtzIG9mIHRoZSBncmFwaFxuICAgICAgICBub2RlLmRlcHRoID0gY3VycmVudERlcHRoO1xuICAgICAgICB0cmF2ZXJzZShub2RlLm91dCwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShub2RlU3RhY2spLCBbbm9kZV0pLCBjdXJyZW50RGVwdGggKyAobm9kZS5za2lwID8gMCA6IDEpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoX2xvb3AoKSkgY29udGludWU7XG4gICAgfVxuICB9XG59XG5cbi8vXG5cbnZhciBEQUdfTEVWRUxfTk9ERV9SQVRJTyA9IDI7XG5cbi8vIHdoZW5ldmVyIHN0eWxpbmcgcHJvcHMgYXJlIGNoYW5nZWQgdGhhdCByZXF1aXJlIGEgY2FudmFzIHJlZHJhd1xudmFyIG5vdGlmeVJlZHJhdyA9IGZ1bmN0aW9uIG5vdGlmeVJlZHJhdyhfLCBzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUub25OZWVkc1JlZHJhdyAmJiBzdGF0ZS5vbk5lZWRzUmVkcmF3KCk7XG59O1xudmFyIHVwZERhdGFQaG90b25zID0gZnVuY3Rpb24gdXBkRGF0YVBob3RvbnMoXywgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5pc1NoYWRvdykge1xuICAgIC8vIEFkZCBwaG90b24gcGFydGljbGVzXG4gICAgdmFyIGxpbmtQYXJ0aWNsZXNBY2Nlc3NvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVzKTtcbiAgICBzdGF0ZS5ncmFwaERhdGEubGlua3MuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgdmFyIG51bVBob3RvbnMgPSBNYXRoLnJvdW5kKE1hdGguYWJzKGxpbmtQYXJ0aWNsZXNBY2Nlc3NvcihsaW5rKSkpO1xuICAgICAgaWYgKG51bVBob3RvbnMpIHtcbiAgICAgICAgbGluay5fX3Bob3RvbnMgPSBfdG9Db25zdW1hYmxlQXJyYXkoQXJyYXkobnVtUGhvdG9ucykpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBsaW5rLl9fcGhvdG9ucztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcbnZhciBDYW52YXNGb3JjZUdyYXBoID0gS2Fwc3VsZSh7XG4gIHByb3BzOiB7XG4gICAgZ3JhcGhEYXRhOiB7XG4gICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5lbmdpbmVSdW5uaW5nID0gZmFsc2U7IC8vIFBhdXNlIHNpbXVsYXRpb25cbiAgICAgICAgdXBkRGF0YVBob3RvbnMoXywgc3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGFnTW9kZToge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGRhZ01vZGUsIHN0YXRlKSB7XG4gICAgICAgIC8vIHRkLCBidSwgbHIsIHJsLCByYWRpYWxpbiwgcmFkaWFsb3V0XG4gICAgICAgICFkYWdNb2RlICYmIChzdGF0ZS5ncmFwaERhdGEubm9kZXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICByZXR1cm4gbi5meCA9IG4uZnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pOyAvLyB1bmZpeCBub2RlcyB3aGVuIGRpc2FibGluZyBkYWcgbW9kZVxuICAgICAgfVxuICAgIH0sXG4gICAgZGFnTGV2ZWxEaXN0YW5jZToge30sXG4gICAgZGFnTm9kZUZpbHRlcjoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkRhZ0Vycm9yOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZVJlbFNpemU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiA0LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICAvLyBhcmVhIHBlciB2YWwgdW5pdFxuICAgIG5vZGVJZDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdpZCdcbiAgICB9LFxuICAgIG5vZGVWYWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAndmFsJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbm9kZUNvbG9yOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ2NvbG9yJyxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbm9kZUF1dG9Db2xvckJ5OiB7fSxcbiAgICBub2RlQ2FudmFzT2JqZWN0OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIG5vZGVDYW52YXNPYmplY3RNb2RlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAncmVwbGFjZSc7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBub2RlVmlzaWJpbGl0eToge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtTb3VyY2U6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnc291cmNlJ1xuICAgIH0sXG4gICAgbGlua1RhcmdldDoge1xuICAgICAgXCJkZWZhdWx0XCI6ICd0YXJnZXQnXG4gICAgfSxcbiAgICBsaW5rVmlzaWJpbGl0eToge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtDb2xvcjoge1xuICAgICAgXCJkZWZhdWx0XCI6ICdjb2xvcicsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtBdXRvQ29sb3JCeToge30sXG4gICAgbGlua0xpbmVEYXNoOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtXaWR0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtDdXJ2YXR1cmU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rQ2FudmFzT2JqZWN0OiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtDYW52YXNPYmplY3RNb2RlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAncmVwbGFjZSc7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogbm90aWZ5UmVkcmF3XG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxBcnJvd0xlbmd0aDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIGxpbmtEaXJlY3Rpb25hbEFycm93Q29sb3I6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IG5vdGlmeVJlZHJhd1xuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLjUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZSxcbiAgICAgIG9uQ2hhbmdlOiBub3RpZnlSZWRyYXdcbiAgICB9LFxuICAgIC8vIHZhbHVlIGJldHdlZW4gMDw+MSBpbmRpY2F0aW5nIHRoZSByZWxhdGl2ZSBwb3MgYWxvbmcgdGhlIChleHBvc2VkKSBsaW5lXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVzOiB7XG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IHVwZERhdGFQaG90b25zXG4gICAgfSxcbiAgICAvLyBhbmltYXRlIHBob3RvbnMgdHJhdmVsbGluZyBpbiB0aGUgbGluayBkaXJlY3Rpb25cbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkOiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBpbiBsaW5rIGxlbmd0aCByYXRpbyBwZXIgZnJhbWVcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZU9mZnNldDoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gc3RhcnRpbmcgcG9zaXRpb24gb2Zmc2V0IGFsb25nIHRoZSBsaW5rJ3MgbGVuZ3RoLCBsaWtlIGEgcHJlLWRlbGF5LiBWYWx1ZXMgYmV0d2VlbiBbMCwgMV1cbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVdpZHRoOiB7XG4gICAgICBcImRlZmF1bHRcIjogNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0RpcmVjdGlvbmFsUGFydGljbGVDYW52YXNPYmplY3Q6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBnbG9iYWxTY2FsZToge1xuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZDNBbHBoYU1pbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZDNBbHBoYURlY2F5OiB7XG4gICAgICBcImRlZmF1bHRcIjogMC4wMjI4LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoYWxwaGFEZWNheSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuYWxwaGFEZWNheShhbHBoYURlY2F5KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQzQWxwaGFUYXJnZXQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2UsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoYWxwaGFUYXJnZXQsIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LmFscGhhVGFyZ2V0KGFscGhhVGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQzVmVsb2NpdHlEZWNheToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuNCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKHZlbG9jaXR5RGVjYXksIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLmZvcmNlTGF5b3V0LnZlbG9jaXR5RGVjYXkodmVsb2NpdHlEZWNheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXJtdXBUaWNrczoge1xuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgLy8gaG93IG1hbnkgdGltZXMgdG8gdGljayB0aGUgZm9yY2UgZW5naW5lIGF0IGluaXQgYmVmb3JlIHN0YXJ0aW5nIHRvIHJlbmRlclxuICAgIGNvb2xkb3duVGlja3M6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBJbmZpbml0eSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBjb29sZG93blRpbWU6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxNTAwMCxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyBtc1xuICAgIG9uVXBkYXRlOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkZpbmlzaFVwZGF0ZToge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25FbmdpbmVUaWNrOiB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24gX2RlZmF1bHQoKSB7fSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkVuZ2luZVN0b3A6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHt9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTmVlZHNSZWRyYXc6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBpc1NoYWRvdzoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICAvLyBFeHBvc2UgZDMgZm9yY2VzIGZvciBleHRlcm5hbCBtYW5pcHVsYXRpb25cbiAgICBkM0ZvcmNlOiBmdW5jdGlvbiBkM0ZvcmNlKHN0YXRlLCBmb3JjZU5hbWUsIGZvcmNlRm4pIHtcbiAgICAgIGlmIChmb3JjZUZuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmZvcmNlTGF5b3V0LmZvcmNlKGZvcmNlTmFtZSk7IC8vIEZvcmNlIGdldHRlclxuICAgICAgfVxuICAgICAgc3RhdGUuZm9yY2VMYXlvdXQuZm9yY2UoZm9yY2VOYW1lLCBmb3JjZUZuKTsgLy8gRm9yY2Ugc2V0dGVyXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGQzUmVoZWF0U2ltdWxhdGlvbjogZnVuY3Rpb24gZDNSZWhlYXRTaW11bGF0aW9uKHN0YXRlKSB7XG4gICAgICBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYSgxKTtcbiAgICAgIHRoaXMucmVzZXRDb3VudGRvd24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gcmVzZXQgY29vbGRvd24gc3RhdGVcbiAgICByZXNldENvdW50ZG93bjogZnVuY3Rpb24gcmVzZXRDb3VudGRvd24oc3RhdGUpIHtcbiAgICAgIHN0YXRlLmNudFRpY2tzID0gMDtcbiAgICAgIHN0YXRlLnN0YXJ0VGlja1RpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGlzRW5naW5lUnVubmluZzogZnVuY3Rpb24gaXNFbmdpbmVSdW5uaW5nKHN0YXRlKSB7XG4gICAgICByZXR1cm4gISFzdGF0ZS5lbmdpbmVSdW5uaW5nO1xuICAgIH0sXG4gICAgdGlja0ZyYW1lOiBmdW5jdGlvbiB0aWNrRnJhbWUoc3RhdGUpIHtcbiAgICAgICFzdGF0ZS5pc1NoYWRvdyAmJiBsYXlvdXRUaWNrKCk7XG4gICAgICBwYWludExpbmtzKCk7XG4gICAgICAhc3RhdGUuaXNTaGFkb3cgJiYgcGFpbnRBcnJvd3MoKTtcbiAgICAgICFzdGF0ZS5pc1NoYWRvdyAmJiBwYWludFBob3RvbnMoKTtcbiAgICAgIHBhaW50Tm9kZXMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvL1xuXG4gICAgICBmdW5jdGlvbiBsYXlvdXRUaWNrKCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5naW5lUnVubmluZykge1xuICAgICAgICAgIGlmICgrK3N0YXRlLmNudFRpY2tzID4gc3RhdGUuY29vbGRvd25UaWNrcyB8fCBuZXcgRGF0ZSgpIC0gc3RhdGUuc3RhcnRUaWNrVGltZSA+IHN0YXRlLmNvb2xkb3duVGltZSB8fCBzdGF0ZS5kM0FscGhhTWluID4gMCAmJiBzdGF0ZS5mb3JjZUxheW91dC5hbHBoYSgpIDwgc3RhdGUuZDNBbHBoYU1pbikge1xuICAgICAgICAgICAgc3RhdGUuZW5naW5lUnVubmluZyA9IGZhbHNlOyAvLyBTdG9wIHRpY2tpbmcgZ3JhcGhcbiAgICAgICAgICAgIHN0YXRlLm9uRW5naW5lU3RvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZS5mb3JjZUxheW91dC50aWNrKCk7IC8vIFRpY2sgaXRcbiAgICAgICAgICAgIHN0YXRlLm9uRW5naW5lVGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnROb2RlcygpIHtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLm5vZGVWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldFZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZUNvbG9yKTtcbiAgICAgICAgdmFyIGdldE5vZGVDYW52YXNPYmplY3RNb2RlID0gYWNjZXNzb3JGbihzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0TW9kZSk7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG5cbiAgICAgICAgLy8gRHJhdyB3aWRlciBub2RlcyBieSAxcHggb24gc2hhZG93IGNhbnZhcyBmb3IgbW9yZSBwcmVjaXNlIGhvdmVyaW5nIChkdWUgdG8gYm91bmRhcnkgYW50aS1hbGlhc2luZylcbiAgICAgICAgdmFyIHBhZEFtb3VudCA9IHN0YXRlLmlzU2hhZG93IC8gc3RhdGUuZ2xvYmFsU2NhbGU7XG4gICAgICAgIHZhciB2aXNpYmxlTm9kZXMgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKGdldFZpc2liaWxpdHkpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB2aXNpYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHZhciBub2RlQ2FudmFzT2JqZWN0TW9kZSA9IGdldE5vZGVDYW52YXNPYmplY3RNb2RlKG5vZGUpO1xuICAgICAgICAgIGlmIChzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0ICYmIChub2RlQ2FudmFzT2JqZWN0TW9kZSA9PT0gJ2JlZm9yZScgfHwgbm9kZUNhbnZhc09iamVjdE1vZGUgPT09ICdyZXBsYWNlJykpIHtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBub2RlIGJlZm9yZS9yZXBsYWNlIHBhaW50XG4gICAgICAgICAgICBzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0KG5vZGUsIGN0eCwgc3RhdGUuZ2xvYmFsU2NhbGUpO1xuICAgICAgICAgICAgaWYgKG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERyYXcgd2lkZXIgbm9kZXMgYnkgMXB4IG9uIHNoYWRvdyBjYW52YXMgZm9yIG1vcmUgcHJlY2lzZSBob3ZlcmluZyAoZHVlIHRvIGJvdW5kYXJ5IGFudGktYWxpYXNpbmcpXG4gICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgZ2V0VmFsKG5vZGUpIHx8IDEpKSAqIHN0YXRlLm5vZGVSZWxTaXplICsgcGFkQW1vdW50O1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHguYXJjKG5vZGUueCwgbm9kZS55LCByLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBnZXRDb2xvcihub2RlKSB8fCAncmdiYSgzMSwgMTIwLCAxODAsIDAuOTIpJztcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5ub2RlQ2FudmFzT2JqZWN0ICYmIG5vZGVDYW52YXNPYmplY3RNb2RlID09PSAnYWZ0ZXInKSB7XG4gICAgICAgICAgICAvLyBDdXN0b20gbm9kZSBhZnRlciBwYWludFxuICAgICAgICAgICAgc3RhdGUubm9kZUNhbnZhc09iamVjdChub2RlLCBzdGF0ZS5jdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnRMaW5rcygpIHtcbiAgICAgICAgdmFyIGdldFZpc2liaWxpdHkgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtWaXNpYmlsaXR5KTtcbiAgICAgICAgdmFyIGdldENvbG9yID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rQ29sb3IpO1xuICAgICAgICB2YXIgZ2V0V2lkdGggPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtXaWR0aCk7XG4gICAgICAgIHZhciBnZXRMaW5lRGFzaCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0xpbmVEYXNoKTtcbiAgICAgICAgdmFyIGdldEN1cnZhdHVyZSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0N1cnZhdHVyZSk7XG4gICAgICAgIHZhciBnZXRMaW5rQ2FudmFzT2JqZWN0TW9kZSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0NhbnZhc09iamVjdE1vZGUpO1xuICAgICAgICB2YXIgY3R4ID0gc3RhdGUuY3R4O1xuXG4gICAgICAgIC8vIERyYXcgd2lkZXIgbGluZXMgYnkgMnB4IG9uIHNoYWRvdyBjYW52YXMgZm9yIG1vcmUgcHJlY2lzZSBob3ZlcmluZyAoZHVlIHRvIGJvdW5kYXJ5IGFudGktYWxpYXNpbmcpXG4gICAgICAgIHZhciBwYWRBbW91bnQgPSBzdGF0ZS5pc1NoYWRvdyAqIDI7XG4gICAgICAgIHZhciB2aXNpYmxlTGlua3MgPSBzdGF0ZS5ncmFwaERhdGEubGlua3MuZmlsdGVyKGdldFZpc2liaWxpdHkpO1xuICAgICAgICB2aXNpYmxlTGlua3MuZm9yRWFjaChjYWxjTGlua0NvbnRyb2xQb2ludHMpOyAvLyBjYWxjdWxhdGUgY3VydmF0dXJlIGNvbnRyb2wgcG9pbnRzIGZvciBhbGwgdmlzaWJsZSBsaW5rc1xuXG4gICAgICAgIHZhciBiZWZvcmVDdXN0b21MaW5rcyA9IFtdLFxuICAgICAgICAgIGFmdGVyQ3VzdG9tTGlua3MgPSBbXSxcbiAgICAgICAgICBkZWZhdWx0UGFpbnRMaW5rcyA9IHZpc2libGVMaW5rcztcbiAgICAgICAgaWYgKHN0YXRlLmxpbmtDYW52YXNPYmplY3QpIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZUN1c3RvbUxpbmtzID0gW10sXG4gICAgICAgICAgICBvdGhlckN1c3RvbUxpbmtzID0gW107XG4gICAgICAgICAgdmlzaWJsZUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICBiZWZvcmU6IGJlZm9yZUN1c3RvbUxpbmtzLFxuICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXJDdXN0b21MaW5rcyxcbiAgICAgICAgICAgICAgcmVwbGFjZTogcmVwbGFjZUN1c3RvbUxpbmtzXG4gICAgICAgICAgICB9W2dldExpbmtDYW52YXNPYmplY3RNb2RlKGQpXSB8fCBvdGhlckN1c3RvbUxpbmtzKS5wdXNoKGQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRlZmF1bHRQYWludExpbmtzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShiZWZvcmVDdXN0b21MaW5rcyksIGFmdGVyQ3VzdG9tTGlua3MsIG90aGVyQ3VzdG9tTGlua3MpO1xuICAgICAgICAgIGJlZm9yZUN1c3RvbUxpbmtzID0gYmVmb3JlQ3VzdG9tTGlua3MuY29uY2F0KHJlcGxhY2VDdXN0b21MaW5rcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDdXN0b20gbGluayBiZWZvcmUgcGFpbnRzXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGJlZm9yZUN1c3RvbUxpbmtzLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubGlua0NhbnZhc09iamVjdChsaW5rLCBjdHgsIHN0YXRlLmdsb2JhbFNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgLy8gQnVuZGxlIHN0cm9rZXMgcGVyIHVuaXF1ZSBjb2xvci93aWR0aC9kYXNoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25cbiAgICAgICAgdmFyIGxpbmtzUGVyQ29sb3IgPSBpbmRleEJ5KGRlZmF1bHRQYWludExpbmtzLCBbZ2V0Q29sb3IsIGdldFdpZHRoLCBnZXRMaW5lRGFzaF0pO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhsaW5rc1BlckNvbG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgICBjb2xvciA9IF9yZWYyWzBdLFxuICAgICAgICAgICAgbGlua3NQZXJXaWR0aCA9IF9yZWYyWzFdO1xuICAgICAgICAgIHZhciBsaW5lQ29sb3IgPSAhY29sb3IgfHwgY29sb3IgPT09ICd1bmRlZmluZWQnID8gJ3JnYmEoMCwwLDAsMC4xNSknIDogY29sb3I7XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMobGlua3NQZXJXaWR0aCkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICAgICAgd2lkdGggPSBfcmVmNFswXSxcbiAgICAgICAgICAgICAgbGluZXNQZXJMaW5lRGFzaCA9IF9yZWY0WzFdO1xuICAgICAgICAgICAgdmFyIGxpbmVXaWR0aCA9ICh3aWR0aCB8fCAxKSAvIHN0YXRlLmdsb2JhbFNjYWxlICsgcGFkQW1vdW50O1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMobGluZXNQZXJMaW5lRGFzaCkuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpO1xuICAgICAgICAgICAgICAgIF9yZWY2WzBdO1xuICAgICAgICAgICAgICAgIHZhciBsaW5rcyA9IF9yZWY2WzFdO1xuICAgICAgICAgICAgICB2YXIgbGluZURhc2hTZWdtZW50cyA9IGdldExpbmVEYXNoKGxpbmtzWzBdKTtcbiAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2U7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBsaW5rLl9fY29udHJvbFBvaW50cztcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xQb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN0cmFpZ2h0IGxpbmVcbiAgICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oZW5kLngsIGVuZC55KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gVXNlIHF1YWRyYXRpYyBjdXJ2ZXMgZm9yIHJlZ3VsYXIgbGluZXMgYW5kIGJlemllciBmb3IgbG9vcHNcbiAgICAgICAgICAgICAgICAgIGN0eFtjb250cm9sUG9pbnRzLmxlbmd0aCA9PT0gMiA/ICdxdWFkcmF0aWNDdXJ2ZVRvJyA6ICdiZXppZXJDdXJ2ZVRvJ10uYXBwbHkoY3R4LCBfdG9Db25zdW1hYmxlQXJyYXkoY29udHJvbFBvaW50cykuY29uY2F0KFtlbmQueCwgZW5kLnldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGluZUNvbG9yO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2hTZWdtZW50cyB8fCBbXSk7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAvLyBDdXN0b20gbGluayBhZnRlciBwYWludHNcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgYWZ0ZXJDdXN0b21MaW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLmxpbmtDYW52YXNPYmplY3QobGluaywgY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gY2FsY0xpbmtDb250cm9sUG9pbnRzKGxpbmspIHtcbiAgICAgICAgICB2YXIgY3VydmF0dXJlID0gZ2V0Q3VydmF0dXJlKGxpbmspO1xuICAgICAgICAgIGlmICghY3VydmF0dXJlKSB7XG4gICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lXG4gICAgICAgICAgICBsaW5rLl9fY29udHJvbFBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgbCA9IE1hdGguc3FydChNYXRoLnBvdyhlbmQueCAtIHN0YXJ0LngsIDIpICsgTWF0aC5wb3coZW5kLnkgLSBzdGFydC55LCAyKSk7IC8vIGxpbmUgbGVuZ3RoXG5cbiAgICAgICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgICAgIHZhciBhID0gTWF0aC5hdGFuMihlbmQueSAtIHN0YXJ0LnksIGVuZC54IC0gc3RhcnQueCk7IC8vIGxpbmUgYW5nbGVcbiAgICAgICAgICAgIHZhciBkID0gbCAqIGN1cnZhdHVyZTsgLy8gY29udHJvbCBwb2ludCBkaXN0YW5jZVxuXG4gICAgICAgICAgICB2YXIgY3AgPSB7XG4gICAgICAgICAgICAgIC8vIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgICAgICAgeDogKHN0YXJ0LnggKyBlbmQueCkgLyAyICsgZCAqIE1hdGguY29zKGEgLSBNYXRoLlBJIC8gMiksXG4gICAgICAgICAgICAgIHk6IChzdGFydC55ICsgZW5kLnkpIC8gMiArIGQgKiBNYXRoLnNpbihhIC0gTWF0aC5QSSAvIDIpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGluay5fX2NvbnRyb2xQb2ludHMgPSBbY3AueCwgY3AueV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNhbWUgcG9pbnQsIGRyYXcgYSBsb29wXG4gICAgICAgICAgICB2YXIgX2QgPSBjdXJ2YXR1cmUgKiA3MDtcbiAgICAgICAgICAgIGxpbmsuX19jb250cm9sUG9pbnRzID0gW2VuZC54LCBlbmQueSAtIF9kLCBlbmQueCArIF9kLCBlbmQueV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwYWludEFycm93cygpIHtcbiAgICAgICAgdmFyIEFSUk9XX1dIX1JBVElPID0gMS42O1xuICAgICAgICB2YXIgQVJST1dfVkxFTl9SQVRJTyA9IDAuMjtcbiAgICAgICAgdmFyIGdldExlbmd0aCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dMZW5ndGgpO1xuICAgICAgICB2YXIgZ2V0UmVsUG9zID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxBcnJvd1JlbFBvcyk7XG4gICAgICAgIHZhciBnZXRWaXNpYmlsaXR5ID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rVmlzaWJpbGl0eSk7XG4gICAgICAgIHZhciBnZXRDb2xvciA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsQXJyb3dDb2xvciB8fCBzdGF0ZS5saW5rQ29sb3IpO1xuICAgICAgICB2YXIgZ2V0Tm9kZVZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICAgIHZhciBjdHggPSBzdGF0ZS5jdHg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5maWx0ZXIoZ2V0VmlzaWJpbGl0eSkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgIHZhciBhcnJvd0xlbmd0aCA9IGdldExlbmd0aChsaW5rKTtcbiAgICAgICAgICBpZiAoIWFycm93TGVuZ3RoIHx8IGFycm93TGVuZ3RoIDwgMCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBzdGFydCA9IGxpbmsuc291cmNlO1xuICAgICAgICAgIHZhciBlbmQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQgfHwgIXN0YXJ0Lmhhc093blByb3BlcnR5KCd4JykgfHwgIWVuZC5oYXNPd25Qcm9wZXJ0eSgneCcpKSByZXR1cm47IC8vIHNraXAgaW52YWxpZCBsaW5rXG5cbiAgICAgICAgICB2YXIgc3RhcnRSID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldE5vZGVWYWwoc3RhcnQpIHx8IDEpKSAqIHN0YXRlLm5vZGVSZWxTaXplO1xuICAgICAgICAgIHZhciBlbmRSID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldE5vZGVWYWwoZW5kKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgICAgICB2YXIgYXJyb3dSZWxQb3MgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBnZXRSZWxQb3MobGluaykpKTtcbiAgICAgICAgICB2YXIgYXJyb3dDb2xvciA9IGdldENvbG9yKGxpbmspIHx8ICdyZ2JhKDAsMCwwLDAuMjgpJztcbiAgICAgICAgICB2YXIgYXJyb3dIYWxmV2lkdGggPSBhcnJvd0xlbmd0aCAvIEFSUk9XX1dIX1JBVElPIC8gMjtcblxuICAgICAgICAgIC8vIENvbnN0cnVjdCBiZXppZXIgZm9yIGN1cnZlZCBsaW5lc1xuICAgICAgICAgIHZhciBiekxpbmUgPSBsaW5rLl9fY29udHJvbFBvaW50cyAmJiBfY29uc3RydWN0KEJlemllciwgW3N0YXJ0LngsIHN0YXJ0LnldLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGluay5fX2NvbnRyb2xQb2ludHMpLCBbZW5kLngsIGVuZC55XSkpO1xuICAgICAgICAgIHZhciBnZXRDb29yZHNBbG9uZ0xpbmUgPSBiekxpbmUgPyBmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ6TGluZS5nZXQodCk7XG4gICAgICAgICAgfSAvLyBnZXQgcG9zaXRpb24gYWxvbmcgYmV6aWVyIGxpbmVcbiAgICAgICAgICA6IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lOiBpbnRlcnBvbGF0ZSBsaW5lYXJseVxuICAgICAgICAgICAgICB4OiBzdGFydC54ICsgKGVuZC54IC0gc3RhcnQueCkgKiB0IHx8IDAsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0LnkgKyAoZW5kLnkgLSBzdGFydC55KSAqIHQgfHwgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBsaW5lTGVuID0gYnpMaW5lID8gYnpMaW5lLmxlbmd0aCgpIDogTWF0aC5zcXJ0KE1hdGgucG93KGVuZC54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyhlbmQueSAtIHN0YXJ0LnksIDIpKTtcbiAgICAgICAgICB2YXIgcG9zQWxvbmdMaW5lID0gc3RhcnRSICsgYXJyb3dMZW5ndGggKyAobGluZUxlbiAtIHN0YXJ0UiAtIGVuZFIgLSBhcnJvd0xlbmd0aCkgKiBhcnJvd1JlbFBvcztcbiAgICAgICAgICB2YXIgYXJyb3dIZWFkID0gZ2V0Q29vcmRzQWxvbmdMaW5lKHBvc0Fsb25nTGluZSAvIGxpbmVMZW4pO1xuICAgICAgICAgIHZhciBhcnJvd1RhaWwgPSBnZXRDb29yZHNBbG9uZ0xpbmUoKHBvc0Fsb25nTGluZSAtIGFycm93TGVuZ3RoKSAvIGxpbmVMZW4pO1xuICAgICAgICAgIHZhciBhcnJvd1RhaWxWZXJ0ZXggPSBnZXRDb29yZHNBbG9uZ0xpbmUoKHBvc0Fsb25nTGluZSAtIGFycm93TGVuZ3RoICogKDEgLSBBUlJPV19WTEVOX1JBVElPKSkgLyBsaW5lTGVuKTtcbiAgICAgICAgICB2YXIgYXJyb3dUYWlsQW5nbGUgPSBNYXRoLmF0YW4yKGFycm93SGVhZC55IC0gYXJyb3dUYWlsLnksIGFycm93SGVhZC54IC0gYXJyb3dUYWlsLngpIC0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oYXJyb3dIZWFkLngsIGFycm93SGVhZC55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGFycm93VGFpbC54ICsgYXJyb3dIYWxmV2lkdGggKiBNYXRoLmNvcyhhcnJvd1RhaWxBbmdsZSksIGFycm93VGFpbC55ICsgYXJyb3dIYWxmV2lkdGggKiBNYXRoLnNpbihhcnJvd1RhaWxBbmdsZSkpO1xuICAgICAgICAgIGN0eC5saW5lVG8oYXJyb3dUYWlsVmVydGV4LngsIGFycm93VGFpbFZlcnRleC55KTtcbiAgICAgICAgICBjdHgubGluZVRvKGFycm93VGFpbC54IC0gYXJyb3dIYWxmV2lkdGggKiBNYXRoLmNvcyhhcnJvd1RhaWxBbmdsZSksIGFycm93VGFpbC55IC0gYXJyb3dIYWxmV2lkdGggKiBNYXRoLnNpbihhcnJvd1RhaWxBbmdsZSkpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBhcnJvd0NvbG9yO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFpbnRQaG90b25zKCkge1xuICAgICAgICB2YXIgZ2V0TnVtUGhvdG9ucyA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVzKTtcbiAgICAgICAgdmFyIGdldFNwZWVkID0gYWNjZXNzb3JGbihzdGF0ZS5saW5rRGlyZWN0aW9uYWxQYXJ0aWNsZVNwZWVkKTtcbiAgICAgICAgdmFyIGdldE9mZnNldCA9IGFjY2Vzc29yRm4oc3RhdGUubGlua0RpcmVjdGlvbmFsUGFydGljbGVPZmZzZXQpO1xuICAgICAgICB2YXIgZ2V0RGlhbWV0ZXIgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlV2lkdGgpO1xuICAgICAgICB2YXIgZ2V0VmlzaWJpbGl0eSA9IGFjY2Vzc29yRm4oc3RhdGUubGlua1Zpc2liaWxpdHkpO1xuICAgICAgICB2YXIgZ2V0Q29sb3IgPSBhY2Nlc3NvckZuKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ29sb3IgfHwgc3RhdGUubGlua0NvbG9yKTtcbiAgICAgICAgdmFyIGN0eCA9IHN0YXRlLmN0eDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgc3RhdGUuZ3JhcGhEYXRhLmxpbmtzLmZpbHRlcihnZXRWaXNpYmlsaXR5KS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgICAgdmFyIG51bUN5Y2xlUGhvdG9ucyA9IGdldE51bVBob3RvbnMobGluayk7XG4gICAgICAgICAgaWYgKCFsaW5rLmhhc093blByb3BlcnR5KCdfX3Bob3RvbnMnKSB8fCAhbGluay5fX3Bob3RvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gbGluay5zb3VyY2U7XG4gICAgICAgICAgdmFyIGVuZCA9IGxpbmsudGFyZ2V0O1xuICAgICAgICAgIGlmICghc3RhcnQgfHwgIWVuZCB8fCAhc3RhcnQuaGFzT3duUHJvcGVydHkoJ3gnKSB8fCAhZW5kLmhhc093blByb3BlcnR5KCd4JykpIHJldHVybjsgLy8gc2tpcCBpbnZhbGlkIGxpbmtcblxuICAgICAgICAgIHZhciBwYXJ0aWNsZVNwZWVkID0gZ2V0U3BlZWQobGluayk7XG4gICAgICAgICAgdmFyIHBhcnRpY2xlT2Zmc2V0ID0gTWF0aC5hYnMoZ2V0T2Zmc2V0KGxpbmspKTtcbiAgICAgICAgICB2YXIgcGhvdG9ucyA9IGxpbmsuX19waG90b25zIHx8IFtdO1xuICAgICAgICAgIHZhciBwaG90b25SID0gTWF0aC5tYXgoMCwgZ2V0RGlhbWV0ZXIobGluaykgLyAyKSAvIE1hdGguc3FydChzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgICAgdmFyIHBob3RvbkNvbG9yID0gZ2V0Q29sb3IobGluaykgfHwgJ3JnYmEoMCwwLDAsMC4yOCknO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBwaG90b25Db2xvcjtcblxuICAgICAgICAgIC8vIENvbnN0cnVjdCBiZXppZXIgZm9yIGN1cnZlZCBsaW5lc1xuICAgICAgICAgIHZhciBiekxpbmUgPSBsaW5rLl9fY29udHJvbFBvaW50cyA/IF9jb25zdHJ1Y3QoQmV6aWVyLCBbc3RhcnQueCwgc3RhcnQueV0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5rLl9fY29udHJvbFBvaW50cyksIFtlbmQueCwgZW5kLnldKSkgOiBudWxsO1xuICAgICAgICAgIHZhciBjeWNsZVBob3RvbklkeCA9IDA7XG4gICAgICAgICAgdmFyIG5lZWRzQ2xlYW51cCA9IGZhbHNlOyAvLyB3aGV0aGVyIHNvbWUgcGhvdG9ucyBuZWVkIHRvIGJlIHJlbW92ZWQgZnJvbSBsaXN0XG4gICAgICAgICAgcGhvdG9ucy5mb3JFYWNoKGZ1bmN0aW9uIChwaG90b24pIHtcbiAgICAgICAgICAgIHZhciBzaW5nbGVIb3AgPSAhIXBob3Rvbi5fX3NpbmdsZUhvcDtcbiAgICAgICAgICAgIGlmICghcGhvdG9uLmhhc093blByb3BlcnR5KCdfX3Byb2dyZXNzUmF0aW8nKSkge1xuICAgICAgICAgICAgICBwaG90b24uX19wcm9ncmVzc1JhdGlvID0gc2luZ2xlSG9wID8gMCA6IChjeWNsZVBob3RvbklkeCArIHBhcnRpY2xlT2Zmc2V0KSAvIG51bUN5Y2xlUGhvdG9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICFzaW5nbGVIb3AgJiYgY3ljbGVQaG90b25JZHgrKzsgLy8gaW5jcmVhc2UgcmVndWxhciBwaG90b24gaW5kZXhcblxuICAgICAgICAgICAgcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbyArPSBwYXJ0aWNsZVNwZWVkO1xuICAgICAgICAgICAgaWYgKHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPj0gMSkge1xuICAgICAgICAgICAgICBpZiAoIXNpbmdsZUhvcCkge1xuICAgICAgICAgICAgICAgIHBob3Rvbi5fX3Byb2dyZXNzUmF0aW8gPSBwaG90b24uX19wcm9ncmVzc1JhdGlvICUgMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZWVkc0NsZWFudXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBob3RvblBvc1JhdGlvID0gcGhvdG9uLl9fcHJvZ3Jlc3NSYXRpbztcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBiekxpbmUgPyBiekxpbmUuZ2V0KHBob3RvblBvc1JhdGlvKSAvLyBnZXQgcG9zaXRpb24gYWxvbmcgYmV6aWVyIGxpbmVcbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAvLyBzdHJhaWdodCBsaW5lOiBpbnRlcnBvbGF0ZSBsaW5lYXJseVxuICAgICAgICAgICAgICB4OiBzdGFydC54ICsgKGVuZC54IC0gc3RhcnQueCkgKiBwaG90b25Qb3NSYXRpbyB8fCAwLFxuICAgICAgICAgICAgICB5OiBzdGFydC55ICsgKGVuZC55IC0gc3RhcnQueSkgKiBwaG90b25Qb3NSYXRpbyB8fCAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ2FudmFzT2JqZWN0KSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ2FudmFzT2JqZWN0KGNvb3Jkcy54LCBjb29yZHMueSwgbGluaywgY3R4LCBzdGF0ZS5nbG9iYWxTY2FsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgIGN0eC5hcmMoY29vcmRzLngsIGNvb3Jkcy55LCBwaG90b25SLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChuZWVkc0NsZWFudXApIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBleHBpcmVkIHNpbmdsZSBob3AgcGhvdG9uc1xuICAgICAgICAgICAgbGluay5fX3Bob3RvbnMgPSBsaW5rLl9fcGhvdG9ucy5maWx0ZXIoZnVuY3Rpb24gKHBob3Rvbikge1xuICAgICAgICAgICAgICByZXR1cm4gIXBob3Rvbi5fX3NpbmdsZUhvcCB8fCBwaG90b24uX19wcm9ncmVzc1JhdGlvIDw9IDE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW1pdFBhcnRpY2xlOiBmdW5jdGlvbiBlbWl0UGFydGljbGUoc3RhdGUsIGxpbmspIHtcbiAgICAgIGlmIChsaW5rKSB7XG4gICAgICAgICFsaW5rLl9fcGhvdG9ucyAmJiAobGluay5fX3Bob3RvbnMgPSBbXSk7XG4gICAgICAgIGxpbmsuX19waG90b25zLnB1c2goe1xuICAgICAgICAgIF9fc2luZ2xlSG9wOiB0cnVlXG4gICAgICAgIH0pOyAvLyBhZGQgYSBzaW5nbGUgaG9wIHBhcnRpY2xlXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sXG4gIHN0YXRlSW5pdDogZnVuY3Rpb24gc3RhdGVJbml0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBmb3JjZUxheW91dDogZm9yY2VTaW11bGF0aW9uKCkuZm9yY2UoJ2xpbmsnLCBmb3JjZUxpbmsoKSkuZm9yY2UoJ2NoYXJnZScsIGZvcmNlTWFueUJvZHkoKSkuZm9yY2UoJ2NlbnRlcicsIGZvcmNlQ2VudGVyKCkpLmZvcmNlKCdkYWdSYWRpYWwnLCBudWxsKS5zdG9wKCksXG4gICAgICBlbmdpbmVSdW5uaW5nOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoY2FudmFzQ3R4LCBzdGF0ZSkge1xuICAgIC8vIE1haW4gY2FudmFzIG9iamVjdCB0byBtYW5pcHVsYXRlXG4gICAgc3RhdGUuY3R4ID0gY2FudmFzQ3R4O1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShzdGF0ZSwgY2hhbmdlZFByb3BzKSB7XG4gICAgc3RhdGUuZW5naW5lUnVubmluZyA9IGZhbHNlOyAvLyBQYXVzZSBzaW11bGF0aW9uXG4gICAgc3RhdGUub25VcGRhdGUoKTtcbiAgICBpZiAoc3RhdGUubm9kZUF1dG9Db2xvckJ5ICE9PSBudWxsKSB7XG4gICAgICAvLyBBdXRvIGFkZCBjb2xvciB0byB1bmNvbG9yZWQgbm9kZXNcbiAgICAgIGF1dG9Db2xvck9iamVjdHMoc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLCBhY2Nlc3NvckZuKHN0YXRlLm5vZGVBdXRvQ29sb3JCeSksIHN0YXRlLm5vZGVDb2xvcik7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5saW5rQXV0b0NvbG9yQnkgIT09IG51bGwpIHtcbiAgICAgIC8vIEF1dG8gYWRkIGNvbG9yIHRvIHVuY29sb3JlZCBsaW5rc1xuICAgICAgYXV0b0NvbG9yT2JqZWN0cyhzdGF0ZS5ncmFwaERhdGEubGlua3MsIGFjY2Vzc29yRm4oc3RhdGUubGlua0F1dG9Db2xvckJ5KSwgc3RhdGUubGlua0NvbG9yKTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBsaW5rc1xuICAgIHN0YXRlLmdyYXBoRGF0YS5saW5rcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICBsaW5rLnNvdXJjZSA9IGxpbmtbc3RhdGUubGlua1NvdXJjZV07XG4gICAgICBsaW5rLnRhcmdldCA9IGxpbmtbc3RhdGUubGlua1RhcmdldF07XG4gICAgfSk7XG5cbiAgICAvLyBGZWVkIGRhdGEgdG8gZm9yY2UtZGlyZWN0ZWQgbGF5b3V0XG4gICAgc3RhdGUuZm9yY2VMYXlvdXQuc3RvcCgpLmFscGhhKDEpIC8vIHJlLWhlYXQgdGhlIHNpbXVsYXRpb25cbiAgICAubm9kZXMoc3RhdGUuZ3JhcGhEYXRhLm5vZGVzKTtcblxuICAgIC8vIGFkZCBsaW5rcyAoaWYgbGluayBmb3JjZSBpcyBzdGlsbCBhY3RpdmUpXG4gICAgdmFyIGxpbmtGb3JjZSA9IHN0YXRlLmZvcmNlTGF5b3V0LmZvcmNlKCdsaW5rJyk7XG4gICAgaWYgKGxpbmtGb3JjZSkge1xuICAgICAgbGlua0ZvcmNlLmlkKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkW3N0YXRlLm5vZGVJZF07XG4gICAgICB9KS5saW5rcyhzdGF0ZS5ncmFwaERhdGEubGlua3MpO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGRhZyBmb3JjZSBjb25zdHJhaW50c1xuICAgIHZhciBub2RlRGVwdGhzID0gc3RhdGUuZGFnTW9kZSAmJiBnZXREYWdEZXB0aHMoc3RhdGUuZ3JhcGhEYXRhLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGVbc3RhdGUubm9kZUlkXTtcbiAgICB9LCB7XG4gICAgICBub2RlRmlsdGVyOiBzdGF0ZS5kYWdOb2RlRmlsdGVyLFxuICAgICAgb25Mb29wRXJyb3I6IHN0YXRlLm9uRGFnRXJyb3IgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gICAgdmFyIG1heERlcHRoID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC52YWx1ZXMobm9kZURlcHRocyB8fCBbXSkpKTtcbiAgICB2YXIgZGFnTGV2ZWxEaXN0YW5jZSA9IHN0YXRlLmRhZ0xldmVsRGlzdGFuY2UgfHwgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmxlbmd0aCAvIChtYXhEZXB0aCB8fCAxKSAqIERBR19MRVZFTF9OT0RFX1JBVElPICogKFsncmFkaWFsaW4nLCAncmFkaWFsb3V0J10uaW5kZXhPZihzdGF0ZS5kYWdNb2RlKSAhPT0gLTEgPyAwLjcgOiAxKTtcblxuICAgIC8vIFJlc2V0IHJlbGV2YW50IGZ4L2Z5IHdoZW4gc3dhcHBpbmcgZGFnIG1vZGVzXG4gICAgaWYgKFsnbHInLCAncmwnLCAndGQnLCAnYnUnXS5pbmNsdWRlcyhjaGFuZ2VkUHJvcHMuZGFnTW9kZSkpIHtcbiAgICAgIHZhciByZXNldFByb3AgPSBbJ2xyJywgJ3JsJ10uaW5jbHVkZXMoY2hhbmdlZFByb3BzLmRhZ01vZGUpID8gJ2Z4JyA6ICdmeSc7XG4gICAgICBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKHN0YXRlLmRhZ05vZGVGaWx0ZXIpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSBub2RlW3Jlc2V0UHJvcF07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBGaXggbm9kZXMgdG8geCx5IGZvciBkYWcgbW9kZVxuICAgIGlmIChbJ2xyJywgJ3JsJywgJ3RkJywgJ2J1J10uaW5jbHVkZXMoc3RhdGUuZGFnTW9kZSkpIHtcbiAgICAgIHZhciBpbnZlcnQgPSBbJ3JsJywgJ2J1J10uaW5jbHVkZXMoc3RhdGUuZGFnTW9kZSk7XG4gICAgICB2YXIgZml4Rm4gPSBmdW5jdGlvbiBmaXhGbihub2RlKSB7XG4gICAgICAgIHJldHVybiAobm9kZURlcHRoc1tub2RlW3N0YXRlLm5vZGVJZF1dIC0gbWF4RGVwdGggLyAyKSAqIGRhZ0xldmVsRGlzdGFuY2UgKiAoaW52ZXJ0ID8gLTEgOiAxKTtcbiAgICAgIH07XG4gICAgICB2YXIgX3Jlc2V0UHJvcCA9IFsnbHInLCAncmwnXS5pbmNsdWRlcyhzdGF0ZS5kYWdNb2RlKSA/ICdmeCcgOiAnZnknO1xuICAgICAgc3RhdGUuZ3JhcGhEYXRhLm5vZGVzLmZpbHRlcihzdGF0ZS5kYWdOb2RlRmlsdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlW19yZXNldFByb3BdID0gZml4Rm4obm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVc2UgcmFkaWFsIGZvcmNlIGZvciByYWRpYWwgZGFnc1xuICAgIHN0YXRlLmZvcmNlTGF5b3V0LmZvcmNlKCdkYWdSYWRpYWwnLCBbJ3JhZGlhbGluJywgJ3JhZGlhbG91dCddLmluZGV4T2Yoc3RhdGUuZGFnTW9kZSkgIT09IC0xID8gZm9yY2VSYWRpYWwoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBub2RlRGVwdGggPSBub2RlRGVwdGhzW25vZGVbc3RhdGUubm9kZUlkXV0gfHwgLTE7XG4gICAgICByZXR1cm4gKHN0YXRlLmRhZ01vZGUgPT09ICdyYWRpYWxpbicgPyBtYXhEZXB0aCAtIG5vZGVEZXB0aCA6IG5vZGVEZXB0aCkgKiBkYWdMZXZlbERpc3RhbmNlO1xuICAgIH0pLnN0cmVuZ3RoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuZGFnTm9kZUZpbHRlcihub2RlKSA/IDEgOiAwO1xuICAgIH0pIDogbnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS53YXJtdXBUaWNrcyAmJiAhKHN0YXRlLmQzQWxwaGFNaW4gPiAwICYmIHN0YXRlLmZvcmNlTGF5b3V0LmFscGhhKCkgPCBzdGF0ZS5kM0FscGhhTWluKTsgaSsrKSB7XG4gICAgICBzdGF0ZS5mb3JjZUxheW91dC50aWNrKCk7XG4gICAgfSAvLyBJbml0aWFsIHRpY2tzIGJlZm9yZSBzdGFydGluZyB0byByZW5kZXJcblxuICAgIHRoaXMucmVzZXRDb3VudGRvd24oKTtcbiAgICBzdGF0ZS5vbkZpbmlzaFVwZGF0ZSgpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbGlua0thcHN1bGUgKGthcHN1bGVQcm9wTmFtZXMsIGthcHN1bGVUeXBlKSB7XG4gIHZhciBwcm9wTmFtZXMgPSBrYXBzdWxlUHJvcE5hbWVzIGluc3RhbmNlb2YgQXJyYXkgPyBrYXBzdWxlUHJvcE5hbWVzIDogW2thcHN1bGVQcm9wTmFtZXNdO1xuICB2YXIgZHVtbXlLID0gbmV3IGthcHN1bGVUeXBlKCk7IC8vIFRvIGV4dHJhY3QgZGVmYXVsdHNcbiAgZHVtbXlLLl9kZXN0cnVjdG9yICYmIGR1bW15Sy5fZGVzdHJ1Y3RvcigpO1xuICByZXR1cm4ge1xuICAgIGxpbmtQcm9wOiBmdW5jdGlvbiBsaW5rUHJvcChwcm9wKSB7XG4gICAgICAvLyBsaW5rIHByb3BlcnR5IGNvbmZpZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IGR1bW15S1twcm9wXSgpLFxuICAgICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2Uodiwgc3RhdGUpIHtcbiAgICAgICAgICBwcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVtwcm9wTmFtZV1bcHJvcF0odik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgICB9O1xuICAgIH0sXG4gICAgbGlua01ldGhvZDogZnVuY3Rpb24gbGlua01ldGhvZChtZXRob2QpIHtcbiAgICAgIC8vIGxpbmsgbWV0aG9kIHBhc3MtdGhyb3VnaFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJldHVyblZhbHMgPSBbXTtcbiAgICAgICAgcHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICAgICAgdmFyIGthcHN1bGVJbnN0YW5jZSA9IHN0YXRlW3Byb3BOYW1lXTtcbiAgICAgICAgICB2YXIgcmV0dXJuVmFsID0ga2Fwc3VsZUluc3RhbmNlW21ldGhvZF0uYXBwbHkoa2Fwc3VsZUluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgICBpZiAocmV0dXJuVmFsICE9PSBrYXBzdWxlSW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHMucHVzaChyZXR1cm5WYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWxzLmxlbmd0aCA/IHJldHVyblZhbHNbMF0gOiB0aGlzOyAvLyBjaGFpbiBiYXNlZCBvbiB0aGUgcGFyZW50IG9iamVjdCwgbm90IHRoZSBpbm5lciBrYXBzdWxlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIEhPVkVSX0NBTlZBU19USFJPVFRMRV9ERUxBWSA9IDgwMDsgLy8gbXMgdG8gdGhyb3R0bGUgc2hhZG93IGNhbnZhcyB1cGRhdGVzIGZvciBwZXJmIGltcHJvdmVtZW50XG52YXIgWk9PTTJOT0RFU19GQUNUT1IgPSA0O1xudmFyIERSQUdfQ0xJQ0tfVE9MRVJBTkNFX1BYID0gNTsgLy8gSG93IG1hbnkgcHggY2FuIGEgbm9kZSBiZSBhY2NpZGVudGFsbHkgZHJhZ2dlZCBiZWZvcmUgZGlzYWJsaW5nIHRoZSBjbGlja1xuXG4vLyBFeHBvc2UgY29uZmlnIGZyb20gZm9yY2VHcmFwaFxudmFyIGJpbmRGRyA9IGxpbmtLYXBzdWxlKCdmb3JjZUdyYXBoJywgQ2FudmFzRm9yY2VHcmFwaCk7XG52YXIgYmluZEJvdGggPSBsaW5rS2Fwc3VsZShbJ2ZvcmNlR3JhcGgnLCAnc2hhZG93R3JhcGgnXSwgQ2FudmFzRm9yY2VHcmFwaCk7XG52YXIgbGlua2VkUHJvcHMgPSBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgX3RvQ29uc3VtYWJsZUFycmF5KFsnbm9kZUNvbG9yJywgJ25vZGVBdXRvQ29sb3JCeScsICdub2RlQ2FudmFzT2JqZWN0JywgJ25vZGVDYW52YXNPYmplY3RNb2RlJywgJ2xpbmtDb2xvcicsICdsaW5rQXV0b0NvbG9yQnknLCAnbGlua0xpbmVEYXNoJywgJ2xpbmtXaWR0aCcsICdsaW5rQ2FudmFzT2JqZWN0JywgJ2xpbmtDYW52YXNPYmplY3RNb2RlJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93TGVuZ3RoJywgJ2xpbmtEaXJlY3Rpb25hbEFycm93Q29sb3InLCAnbGlua0RpcmVjdGlvbmFsQXJyb3dSZWxQb3MnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVzJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlU3BlZWQnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVPZmZzZXQnLCAnbGlua0RpcmVjdGlvbmFsUGFydGljbGVXaWR0aCcsICdsaW5rRGlyZWN0aW9uYWxQYXJ0aWNsZUNvbG9yJywgJ2xpbmtEaXJlY3Rpb25hbFBhcnRpY2xlQ2FudmFzT2JqZWN0JywgJ2RhZ01vZGUnLCAnZGFnTGV2ZWxEaXN0YW5jZScsICdkYWdOb2RlRmlsdGVyJywgJ29uRGFnRXJyb3InLCAnZDNBbHBoYU1pbicsICdkM0FscGhhRGVjYXknLCAnZDNWZWxvY2l0eURlY2F5JywgJ3dhcm11cFRpY2tzJywgJ2Nvb2xkb3duVGlja3MnLCAnY29vbGRvd25UaW1lJywgJ29uRW5naW5lVGljaycsICdvbkVuZ2luZVN0b3AnXS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgcCwgYmluZEZHLmxpbmtQcm9wKHApKTtcbn0pKS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KFsnbm9kZVJlbFNpemUnLCAnbm9kZUlkJywgJ25vZGVWYWwnLCAnbm9kZVZpc2liaWxpdHknLCAnbGlua1NvdXJjZScsICdsaW5rVGFyZ2V0JywgJ2xpbmtWaXNpYmlsaXR5JywgJ2xpbmtDdXJ2YXR1cmUnXS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgcCwgYmluZEJvdGgubGlua1Byb3AocCkpO1xufSkpKSk7XG52YXIgbGlua2VkTWV0aG9kcyA9IE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LCBfdG9Db25zdW1hYmxlQXJyYXkoWydkM0ZvcmNlJywgJ2QzUmVoZWF0U2ltdWxhdGlvbicsICdlbWl0UGFydGljbGUnXS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgcmV0dXJuIF9kZWZpbmVQcm9wZXJ0eSh7fSwgcCwgYmluZEZHLmxpbmtNZXRob2QocCkpO1xufSkpKTtcbmZ1bmN0aW9uIGFkanVzdENhbnZhc1NpemUoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmNhbnZhcykge1xuICAgIHZhciBjdXJXaWR0aCA9IHN0YXRlLmNhbnZhcy53aWR0aDtcbiAgICB2YXIgY3VySGVpZ2h0ID0gc3RhdGUuY2FudmFzLmhlaWdodDtcbiAgICBpZiAoY3VyV2lkdGggPT09IDMwMCAmJiBjdXJIZWlnaHQgPT09IDE1MCkge1xuICAgICAgLy8gRGVmYXVsdCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgY3VyV2lkdGggPSBjdXJIZWlnaHQgPSAwO1xuICAgIH1cbiAgICB2YXIgcHhTY2FsZSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvOyAvLyAyIG9uIHJldGluYSBkaXNwbGF5c1xuICAgIGN1cldpZHRoIC89IHB4U2NhbGU7XG4gICAgY3VySGVpZ2h0IC89IHB4U2NhbGU7XG5cbiAgICAvLyBSZXNpemUgY2FudmFzZXNcbiAgICBbc3RhdGUuY2FudmFzLCBzdGF0ZS5zaGFkb3dDYW52YXNdLmZvckVhY2goZnVuY3Rpb24gKGNhbnZhcykge1xuICAgICAgLy8gRWxlbWVudCBzaXplXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdChzdGF0ZS53aWR0aCwgXCJweFwiKTtcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChzdGF0ZS5oZWlnaHQsIFwicHhcIik7XG5cbiAgICAgIC8vIE1lbW9yeSBzaXplIChzY2FsZWQgdG8gYXZvaWQgYmx1cnJpbmVzcylcbiAgICAgIGNhbnZhcy53aWR0aCA9IHN0YXRlLndpZHRoICogcHhTY2FsZTtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBzdGF0ZS5oZWlnaHQgKiBweFNjYWxlO1xuXG4gICAgICAvLyBOb3JtYWxpemUgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gdXNlIGNzcyBwaXhlbHMgKG9uIGluaXQgb25seSlcbiAgICAgIGlmICghY3VyV2lkdGggJiYgIWN1ckhlaWdodCkge1xuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5zY2FsZShweFNjYWxlLCBweFNjYWxlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlbGF0aXZlIGNlbnRlciBwYW5uaW5nIGJhc2VkIG9uIDAsMFxuICAgIHZhciBrID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLms7XG4gICAgc3RhdGUuem9vbS50cmFuc2xhdGVCeShzdGF0ZS56b29tLl9fYmFzZUVsZW0sIChzdGF0ZS53aWR0aCAtIGN1cldpZHRoKSAvIDIgLyBrLCAoc3RhdGUuaGVpZ2h0IC0gY3VySGVpZ2h0KSAvIDIgLyBrKTtcbiAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtKGN0eCkge1xuICB2YXIgcHhSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICBjdHguc2V0VHJhbnNmb3JtKHB4UmF0aW8sIDAsIDAsIHB4UmF0aW8sIDAsIDApO1xufVxuZnVuY3Rpb24gY2xlYXJDYW52YXMoY3R4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGN0eC5zYXZlKCk7XG4gIHJlc2V0VHJhbnNmb3JtKGN0eCk7IC8vIHJlc2V0IHRyYW5zZm9ybVxuICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICBjdHgucmVzdG9yZSgpOyAvL3Jlc3RvcmUgdHJhbnNmb3Jtc1xufVxuXG4vL1xuXG52YXIgZm9yY2VHcmFwaCA9IEthcHN1bGUoe1xuICBwcm9wczogX29iamVjdFNwcmVhZDIoe1xuICAgIHdpZHRoOiB7XG4gICAgICBcImRlZmF1bHRcIjogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoXywgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdENhbnZhc1NpemUoc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UoXywgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGFkanVzdENhbnZhc1NpemUoc3RhdGUpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBncmFwaERhdGE6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgbGlua3M6IFtdXG4gICAgICB9LFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGQsIHN0YXRlKSB7XG4gICAgICAgIC8vIFdpcGUgY29sb3IgcmVnaXN0cnkgaWYgYWxsIG9iamVjdHMgYXJlIG5ld1xuICAgICAgICBbZC5ub2RlcywgZC5saW5rc10uZXZlcnkoZnVuY3Rpb24gKGFycikge1xuICAgICAgICAgIHJldHVybiAoYXJyIHx8IFtdKS5ldmVyeShmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuICFkLmhhc093blByb3BlcnR5KCdfX2luZGV4Q29sb3InKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkgJiYgc3RhdGUuY29sb3JUcmFja2VyLnJlc2V0KCk7XG4gICAgICAgIFt7XG4gICAgICAgICAgdHlwZTogJ05vZGUnLFxuICAgICAgICAgIG9ianM6IGQubm9kZXNcbiAgICAgICAgfSwge1xuICAgICAgICAgIHR5cGU6ICdMaW5rJyxcbiAgICAgICAgICBvYmpzOiBkLmxpbmtzXG4gICAgICAgIH1dLmZvckVhY2goaGV4SW5kZXgpO1xuICAgICAgICBzdGF0ZS5mb3JjZUdyYXBoLmdyYXBoRGF0YShkKTtcbiAgICAgICAgc3RhdGUuc2hhZG93R3JhcGguZ3JhcGhEYXRhKGQpO1xuICAgICAgICBmdW5jdGlvbiBoZXhJbmRleChfcmVmNCkge1xuICAgICAgICAgIHZhciB0eXBlID0gX3JlZjQudHlwZSxcbiAgICAgICAgICAgIG9ianMgPSBfcmVmNC5vYmpzO1xuICAgICAgICAgIG9ianMuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICBpZiAoIWQuaGFzT3duUHJvcGVydHkoJ19faW5kZXhDb2xvcicpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjdXIgPSBzdGF0ZS5jb2xvclRyYWNrZXIubG9va3VwKGQuX19pbmRleENvbG9yKTtcbiAgICAgICAgICAgIHJldHVybiAhY3VyIHx8ICFjdXIuaGFzT3duUHJvcGVydHkoJ2QnKSB8fCBjdXIuZCAhPT0gZDtcbiAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAvLyBzdG9yZSBvYmplY3QgbG9va3VwIGNvbG9yXG4gICAgICAgICAgICBkLl9faW5kZXhDb2xvciA9IHN0YXRlLmNvbG9yVHJhY2tlci5yZWdpc3Rlcih7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIGQ6IGRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKGNvbG9yLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5jYW52YXMgJiYgY29sb3IgJiYgKHN0YXRlLmNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kID0gY29sb3IpO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBub2RlTGFiZWw6IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAnbmFtZScsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZVBvaW50ZXJBcmVhUGFpbnQ6IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShwYWludEZuLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5ub2RlQ2FudmFzT2JqZWN0KCFwYWludEZuID8gbnVsbCA6IGZ1bmN0aW9uIChub2RlLCBjdHgsIGdsb2JhbFNjYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhaW50Rm4obm9kZSwgbm9kZS5fX2luZGV4Q29sb3IsIGN0eCwgZ2xvYmFsU2NhbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuZmx1c2hTaGFkb3dDYW52YXMgJiYgc3RhdGUuZmx1c2hTaGFkb3dDYW52YXMoKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua1BvaW50ZXJBcmVhUGFpbnQ6IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShwYWludEZuLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5saW5rQ2FudmFzT2JqZWN0KCFwYWludEZuID8gbnVsbCA6IGZ1bmN0aW9uIChsaW5rLCBjdHgsIGdsb2JhbFNjYWxlKSB7XG4gICAgICAgICAgcmV0dXJuIHBhaW50Rm4obGluaywgbGluay5fX2luZGV4Q29sb3IsIGN0eCwgZ2xvYmFsU2NhbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RhdGUuZmx1c2hTaGFkb3dDYW52YXMgJiYgc3RhdGUuZmx1c2hTaGFkb3dDYW52YXMoKTtcbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbGlua0xhYmVsOiB7XG4gICAgICBcImRlZmF1bHRcIjogJ25hbWUnLFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGxpbmtIb3ZlclByZWNpc2lvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IDQsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgbWluWm9vbToge1xuICAgICAgXCJkZWZhdWx0XCI6IDAuMDEsXG4gICAgICBvbkNoYW5nZTogZnVuY3Rpb24gb25DaGFuZ2UobWluWm9vbSwgc3RhdGUpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZUV4dGVudChbbWluWm9vbSwgc3RhdGUuem9vbS5zY2FsZUV4dGVudCgpWzFdXSk7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG1heFpvb206IHtcbiAgICAgIFwiZGVmYXVsdFwiOiAxMDAwLFxuICAgICAgb25DaGFuZ2U6IGZ1bmN0aW9uIG9uQ2hhbmdlKG1heFpvb20sIHN0YXRlKSB7XG4gICAgICAgIHN0YXRlLnpvb20uc2NhbGVFeHRlbnQoW3N0YXRlLnpvb20uc2NhbGVFeHRlbnQoKVswXSwgbWF4Wm9vbV0pO1xuICAgICAgfSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVOb2RlRHJhZzoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlWm9vbUludGVyYWN0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBlbmFibGVQYW5JbnRlcmFjdGlvbjoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlWm9vbVBhbkludGVyYWN0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICAvLyB0byBiZSBkZXByZWNhdGVkXG4gICAgZW5hYmxlUG9pbnRlckludGVyYWN0aW9uOiB7XG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShfLCBzdGF0ZSkge1xuICAgICAgICBzdGF0ZS5ob3Zlck9iaiA9IG51bGw7XG4gICAgICB9LFxuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIGF1dG9QYXVzZVJlZHJhdzoge1xuICAgICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25Ob2RlRHJhZzoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25Ob2RlRHJhZ0VuZDoge1xuICAgICAgXCJkZWZhdWx0XCI6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge30sXG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25Ob2RlQ2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbk5vZGVSaWdodENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25Ob2RlSG92ZXI6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkxpbmtDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uTGlua1JpZ2h0Q2xpY2s6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvbkxpbmtIb3Zlcjoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uQmFja2dyb3VuZENsaWNrOiB7XG4gICAgICB0cmlnZ2VyVXBkYXRlOiBmYWxzZVxuICAgIH0sXG4gICAgb25CYWNrZ3JvdW5kUmlnaHRDbGljazoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uWm9vbToge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uWm9vbUVuZDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9LFxuICAgIG9uUmVuZGVyRnJhbWVQcmU6IHtcbiAgICAgIHRyaWdnZXJVcGRhdGU6IGZhbHNlXG4gICAgfSxcbiAgICBvblJlbmRlckZyYW1lUG9zdDoge1xuICAgICAgdHJpZ2dlclVwZGF0ZTogZmFsc2VcbiAgICB9XG4gIH0sIGxpbmtlZFByb3BzKSxcbiAgYWxpYXNlczoge1xuICAgIC8vIFByb3AgbmFtZXMgc3VwcG9ydGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIHN0b3BBbmltYXRpb246ICdwYXVzZUFuaW1hdGlvbidcbiAgfSxcbiAgbWV0aG9kczogX29iamVjdFNwcmVhZDIoe1xuICAgIGdyYXBoMlNjcmVlbkNvb3JkczogZnVuY3Rpb24gZ3JhcGgyU2NyZWVuQ29vcmRzKHN0YXRlLCB4LCB5KSB7XG4gICAgICB2YXIgdCA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggKiB0LmsgKyB0LngsXG4gICAgICAgIHk6IHkgKiB0LmsgKyB0LnlcbiAgICAgIH07XG4gICAgfSxcbiAgICBzY3JlZW4yR3JhcGhDb29yZHM6IGZ1bmN0aW9uIHNjcmVlbjJHcmFwaENvb3JkcyhzdGF0ZSwgeCwgeSkge1xuICAgICAgdmFyIHQgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoeCAtIHQueCkgLyB0LmssXG4gICAgICAgIHk6ICh5IC0gdC55KSAvIHQua1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNlbnRlckF0OiBmdW5jdGlvbiBjZW50ZXJBdChzdGF0ZSwgeCwgeSwgdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICBpZiAoIXN0YXRlLmNhbnZhcykgcmV0dXJuIG51bGw7IC8vIG5vIGNhbnZhcyB5ZXRcblxuICAgICAgLy8gc2V0dGVyXG4gICAgICBpZiAoeCAhPT0gdW5kZWZpbmVkIHx8IHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmluYWxQb3MgPSBPYmplY3QuYXNzaWduKHt9LCB4ICE9PSB1bmRlZmluZWQgPyB7XG4gICAgICAgICAgeDogeFxuICAgICAgICB9IDoge30sIHkgIT09IHVuZGVmaW5lZCA/IHtcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0gOiB7fSk7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbm8gYW5pbWF0aW9uXG4gICAgICAgICAgc2V0Q2VudGVyKGZpbmFsUG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50d2Vlbkdyb3VwLmFkZChuZXcgVHdlZW4oZ2V0Q2VudGVyKCkpLnRvKGZpbmFsUG9zLCB0cmFuc2l0aW9uRHVyYXRpb24pLmVhc2luZyhFYXNpbmcuUXVhZHJhdGljLk91dCkub25VcGRhdGUoc2V0Q2VudGVyKS5zdGFydCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0dGVyXG4gICAgICByZXR1cm4gZ2V0Q2VudGVyKCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGdldENlbnRlcigpIHtcbiAgICAgICAgdmFyIHQgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogKHN0YXRlLndpZHRoIC8gMiAtIHQueCkgLyB0LmssXG4gICAgICAgICAgeTogKHN0YXRlLmhlaWdodCAvIDIgLSB0LnkpIC8gdC5rXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXRDZW50ZXIoX3JlZjUpIHtcbiAgICAgICAgdmFyIHggPSBfcmVmNS54LFxuICAgICAgICAgIHkgPSBfcmVmNS55O1xuICAgICAgICBzdGF0ZS56b29tLnRyYW5zbGF0ZVRvKHN0YXRlLnpvb20uX19iYXNlRWxlbSwgeCA9PT0gdW5kZWZpbmVkID8gZ2V0Q2VudGVyKCkueCA6IHgsIHkgPT09IHVuZGVmaW5lZCA/IGdldENlbnRlcigpLnkgOiB5KTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24gem9vbShzdGF0ZSwgaywgdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICBpZiAoIXN0YXRlLmNhbnZhcykgcmV0dXJuIG51bGw7IC8vIG5vIGNhbnZhcyB5ZXRcblxuICAgICAgLy8gc2V0dGVyXG4gICAgICBpZiAoayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghdHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gbm8gYW5pbWF0aW9uXG4gICAgICAgICAgc2V0Wm9vbShrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS50d2Vlbkdyb3VwLmFkZChuZXcgVHdlZW4oe1xuICAgICAgICAgICAgazogZ2V0Wm9vbSgpXG4gICAgICAgICAgfSkudG8oe1xuICAgICAgICAgICAgazoga1xuICAgICAgICAgIH0sIHRyYW5zaXRpb25EdXJhdGlvbikuZWFzaW5nKEVhc2luZy5RdWFkcmF0aWMuT3V0KS5vblVwZGF0ZShmdW5jdGlvbiAoX3JlZjYpIHtcbiAgICAgICAgICAgIHZhciBrID0gX3JlZjYuaztcbiAgICAgICAgICAgIHJldHVybiBzZXRab29tKGspO1xuICAgICAgICAgIH0pLnN0YXJ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIHJldHVybiBnZXRab29tKCk7XG5cbiAgICAgIC8vXG5cbiAgICAgIGZ1bmN0aW9uIGdldFpvb20oKSB7XG4gICAgICAgIHJldHVybiB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcykuaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNldFpvb20oaykge1xuICAgICAgICBzdGF0ZS56b29tLnNjYWxlVG8oc3RhdGUuem9vbS5fX2Jhc2VFbGVtLCBrKTtcbiAgICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgem9vbVRvRml0OiBmdW5jdGlvbiB6b29tVG9GaXQoc3RhdGUpIHtcbiAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTA7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYmJveEFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDMgPyBfbGVuIC0gMyA6IDApLCBfa2V5ID0gMzsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBiYm94QXJnc1tfa2V5IC0gM10gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICB2YXIgYmJveCA9IHRoaXMuZ2V0R3JhcGhCYm94LmFwcGx5KHRoaXMsIGJib3hBcmdzKTtcbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgICAgeDogKGJib3gueFswXSArIGJib3gueFsxXSkgLyAyLFxuICAgICAgICAgIHk6IChiYm94LnlbMF0gKyBiYm94LnlbMV0pIC8gMlxuICAgICAgICB9O1xuICAgICAgICB2YXIgem9vbUsgPSBNYXRoLm1heCgxZS0xMiwgTWF0aC5taW4oMWUxMiwgKHN0YXRlLndpZHRoIC0gcGFkZGluZyAqIDIpIC8gKGJib3gueFsxXSAtIGJib3gueFswXSksIChzdGF0ZS5oZWlnaHQgLSBwYWRkaW5nICogMikgLyAoYmJveC55WzFdIC0gYmJveC55WzBdKSkpO1xuICAgICAgICB0aGlzLmNlbnRlckF0KGNlbnRlci54LCBjZW50ZXIueSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy56b29tKHpvb21LLCB0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRHcmFwaEJib3g6IGZ1bmN0aW9uIGdldEdyYXBoQmJveChzdGF0ZSkge1xuICAgICAgdmFyIG5vZGVGaWx0ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgdmFyIGdldFZhbCA9IGFjY2Vzc29yRm4oc3RhdGUubm9kZVZhbCk7XG4gICAgICB2YXIgZ2V0UiA9IGZ1bmN0aW9uIGdldFIobm9kZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGdldFZhbChub2RlKSB8fCAxKSkgKiBzdGF0ZS5ub2RlUmVsU2l6ZTtcbiAgICAgIH07XG4gICAgICB2YXIgbm9kZXNQb3MgPSBzdGF0ZS5ncmFwaERhdGEubm9kZXMuZmlsdGVyKG5vZGVGaWx0ZXIpLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgICB5OiBub2RlLnksXG4gICAgICAgICAgcjogZ2V0Uihub2RlKVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gIW5vZGVzUG9zLmxlbmd0aCA/IG51bGwgOiB7XG4gICAgICAgIHg6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS54ICsgbm9kZS5yO1xuICAgICAgICB9KV0sXG4gICAgICAgIHk6IFttaW4obm9kZXNQb3MsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGUueSAtIG5vZGUucjtcbiAgICAgICAgfSksIG1heChub2Rlc1BvcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZS55ICsgbm9kZS5yO1xuICAgICAgICB9KV1cbiAgICAgIH07XG4gICAgfSxcbiAgICBwYXVzZUFuaW1hdGlvbjogZnVuY3Rpb24gcGF1c2VBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCk7XG4gICAgICAgIHN0YXRlLmFuaW1hdGlvbkZyYW1lUmVxdWVzdElkID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcmVzdW1lQW5pbWF0aW9uOiBmdW5jdGlvbiByZXN1bWVBbmltYXRpb24oc3RhdGUpIHtcbiAgICAgIGlmICghc3RhdGUuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0SWQpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uQ3ljbGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2Rlc3RydWN0b3I6IGZ1bmN0aW9uIF9kZXN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xuICAgICAgdGhpcy5ncmFwaERhdGEoe1xuICAgICAgICBub2RlczogW10sXG4gICAgICAgIGxpbmtzOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBsaW5rZWRNZXRob2RzKSxcbiAgc3RhdGVJbml0OiBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RTZXRab29tOiAxLFxuICAgICAgem9vbTogem9vbSgpLFxuICAgICAgZm9yY2VHcmFwaDogbmV3IENhbnZhc0ZvcmNlR3JhcGgoKSxcbiAgICAgIHNoYWRvd0dyYXBoOiBuZXcgQ2FudmFzRm9yY2VHcmFwaCgpLmNvb2xkb3duVGlja3MoMCkubm9kZUNvbG9yKCdfX2luZGV4Q29sb3InKS5saW5rQ29sb3IoJ19faW5kZXhDb2xvcicpLmlzU2hhZG93KHRydWUpLFxuICAgICAgY29sb3JUcmFja2VyOiBuZXcgQ29sb3JUcmFja2VyKCksXG4gICAgICAvLyBpbmRleGVkIG9iamVjdHMgZm9yIHJnYiBsb29rdXBcbiAgICAgIHR3ZWVuR3JvdXA6IG5ldyBHcm91cCgpXG4gICAgfTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChkb21Ob2RlLCBzdGF0ZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gV2lwZSBET01cbiAgICBkb21Ob2RlLmlubmVySFRNTCA9ICcnO1xuXG4gICAgLy8gQ29udGFpbmVyIGFuY2hvciBmb3IgY2FudmFzIGFuZCB0b29sdGlwXG4gICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdmb3JjZS1ncmFwaC1jb250YWluZXInKTtcbiAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIGRvbU5vZGUuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBzdGF0ZS5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBpZiAoc3RhdGUuYmFja2dyb3VuZENvbG9yKSBzdGF0ZS5jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9IHN0YXRlLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdGUuY2FudmFzKTtcbiAgICBzdGF0ZS5zaGFkb3dDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIC8vIFNob3cgc2hhZG93IGNhbnZhc1xuICAgIC8vc3RhdGUuc2hhZG93Q2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAvL3N0YXRlLnNoYWRvd0NhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgLy9zdGF0ZS5zaGFkb3dDYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAvL2NvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0ZS5zaGFkb3dDYW52YXMpO1xuXG4gICAgdmFyIGN0eCA9IHN0YXRlLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBzaGFkb3dDdHggPSBzdGF0ZS5zaGFkb3dDYW52YXMuZ2V0Q29udGV4dCgnMmQnLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgICB2YXIgcG9pbnRlclBvcyA9IHtcbiAgICAgIHg6IC0xZTEyLFxuICAgICAgeTogLTFlMTJcbiAgICB9O1xuICAgIHZhciBnZXRPYmpVbmRlclBvaW50ZXIgPSBmdW5jdGlvbiBnZXRPYmpVbmRlclBvaW50ZXIoKSB7XG4gICAgICB2YXIgb2JqID0gbnVsbDtcbiAgICAgIHZhciBweFNjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB2YXIgcHggPSBwb2ludGVyUG9zLnggPiAwICYmIHBvaW50ZXJQb3MueSA+IDAgPyBzaGFkb3dDdHguZ2V0SW1hZ2VEYXRhKHBvaW50ZXJQb3MueCAqIHB4U2NhbGUsIHBvaW50ZXJQb3MueSAqIHB4U2NhbGUsIDEsIDEpIDogbnVsbDtcbiAgICAgIC8vIExvb2t1cCBvYmplY3QgcGVyIHBpeGVsIGNvbG9yXG4gICAgICBweCAmJiAob2JqID0gc3RhdGUuY29sb3JUcmFja2VyLmxvb2t1cChweC5kYXRhKSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG5cbiAgICAvLyBTZXR1cCBub2RlIGRyYWcgaW50ZXJhY3Rpb25cbiAgICBzZWxlY3Qoc3RhdGUuY2FudmFzKS5jYWxsKGRyYWcoKS5zdWJqZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3RhdGUuZW5hYmxlTm9kZURyYWcpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgb2JqID0gZ2V0T2JqVW5kZXJQb2ludGVyKCk7XG4gICAgICByZXR1cm4gb2JqICYmIG9iai50eXBlID09PSAnTm9kZScgPyBvYmouZCA6IG51bGw7IC8vIE9ubHkgZHJhZyBub2Rlc1xuICAgIH0pLm9uKCdzdGFydCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICBvYmouX19pbml0aWFsRHJhZ1BvcyA9IHtcbiAgICAgICAgeDogb2JqLngsXG4gICAgICAgIHk6IG9iai55LFxuICAgICAgICBmeDogb2JqLmZ4LFxuICAgICAgICBmeTogb2JqLmZ5XG4gICAgICB9O1xuXG4gICAgICAvLyBrZWVwIGVuZ2luZSBydW5uaW5nIGF0IGxvdyBpbnRlbnNpdHkgdGhyb3VnaG91dCBkcmFnXG4gICAgICBpZiAoIWV2LmFjdGl2ZSkge1xuICAgICAgICBvYmouZnggPSBvYmoueDtcbiAgICAgICAgb2JqLmZ5ID0gb2JqLnk7IC8vIEZpeCBwb2ludHNcbiAgICAgIH1cblxuICAgICAgLy8gZHJhZyBjdXJzb3JcbiAgICAgIHN0YXRlLmNhbnZhcy5jbGFzc0xpc3QuYWRkKCdncmFiYmFibGUnKTtcbiAgICB9KS5vbignZHJhZycsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICB2YXIgaW5pdFBvcyA9IG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgdmFyIGRyYWdQb3MgPSBldjtcbiAgICAgIHZhciBrID0gem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLms7XG4gICAgICB2YXIgdHJhbnNsYXRlID0ge1xuICAgICAgICB4OiBpbml0UG9zLnggKyAoZHJhZ1Bvcy54IC0gaW5pdFBvcy54KSAvIGsgLSBvYmoueCxcbiAgICAgICAgeTogaW5pdFBvcy55ICsgKGRyYWdQb3MueSAtIGluaXRQb3MueSkgLyBrIC0gb2JqLnlcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdmUgZngvZnkgKGFuZCB4L3kpIG9mIG5vZGVzIGJhc2VkIG9uIHRoZSBzY2FsZWQgZHJhZyBkaXN0YW5jZSBzaW5jZSB0aGUgZHJhZyBzdGFydFxuICAgICAgWyd4JywgJ3knXS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBvYmpbXCJmXCIuY29uY2F0KGMpXSA9IG9ialtjXSA9IGluaXRQb3NbY10gKyAoZHJhZ1Bvc1tjXSAtIGluaXRQb3NbY10pIC8gaztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPbmx5IGVuZ2FnZSBmdWxsIGRyYWcgaWYgZGlzdGFuY2UgcmVhY2hlcyBhYm92ZSB0aHJlc2hvbGRcbiAgICAgIGlmICghb2JqLl9fZHJhZ2dlZCAmJiBEUkFHX0NMSUNLX1RPTEVSQU5DRV9QWCA+PSBNYXRoLnNxcnQoc3VtKFsneCcsICd5J10ubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdyhldltrXSAtIGluaXRQb3Nba10sIDIpO1xuICAgICAgfSkpKSkgcmV0dXJuO1xuICAgICAgc3RhdGUuZm9yY2VHcmFwaC5kM0FscGhhVGFyZ2V0KDAuMykgLy8ga2VlcCBlbmdpbmUgcnVubmluZyBhdCBsb3cgaW50ZW5zaXR5IHRocm91Z2hvdXQgZHJhZ1xuICAgICAgLnJlc2V0Q291bnRkb3duKCk7IC8vIHByZXZlbnQgZnJlZXplIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIG9iai5fX2RyYWdnZWQgPSB0cnVlO1xuICAgICAgc3RhdGUub25Ob2RlRHJhZyhvYmosIHRyYW5zbGF0ZSk7XG4gICAgfSkub24oJ2VuZCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIG9iaiA9IGV2LnN1YmplY3Q7XG4gICAgICB2YXIgaW5pdFBvcyA9IG9iai5fX2luaXRpYWxEcmFnUG9zO1xuICAgICAgdmFyIHRyYW5zbGF0ZSA9IHtcbiAgICAgICAgeDogb2JqLnggLSBpbml0UG9zLngsXG4gICAgICAgIHk6IG9iai55IC0gaW5pdFBvcy55XG4gICAgICB9O1xuICAgICAgaWYgKGluaXRQb3MuZnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmouZnggPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaW5pdFBvcy5meSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9iai5meSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBvYmouX19pbml0aWFsRHJhZ1BvcztcbiAgICAgIGlmIChzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoKSkge1xuICAgICAgICBzdGF0ZS5mb3JjZUdyYXBoLmQzQWxwaGFUYXJnZXQoMCkgLy8gcmVsZWFzZSBlbmdpbmUgbG93IGludGVuc2l0eVxuICAgICAgICAucmVzZXRDb3VudGRvd24oKTsgLy8gbGV0IHRoZSBlbmdpbmUgcmVhZGp1c3QgYWZ0ZXIgcmVsZWFzaW5nIGZpeGVkIG5vZGVzXG4gICAgICB9XG5cbiAgICAgIC8vIGRyYWcgY3Vyc29yXG4gICAgICBzdGF0ZS5jYW52YXMuY2xhc3NMaXN0LnJlbW92ZSgnZ3JhYmJhYmxlJyk7XG4gICAgICBzdGF0ZS5pc1BvaW50ZXJEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgaWYgKG9iai5fX2RyYWdnZWQpIHtcbiAgICAgICAgZGVsZXRlIG9iai5fX2RyYWdnZWQ7XG4gICAgICAgIHN0YXRlLm9uTm9kZURyYWdFbmQob2JqLCB0cmFuc2xhdGUpO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIFNldHVwIHpvb20gLyBwYW4gaW50ZXJhY3Rpb25cbiAgICBzdGF0ZS56b29tKHN0YXRlLnpvb20uX19iYXNlRWxlbSA9IHNlbGVjdChzdGF0ZS5jYW52YXMpKTsgLy8gQXR0YWNoIGNvbnRyb2xsaW5nIGVsZW0gZm9yIGVhc3kgYWNjZXNzXG5cbiAgICBzdGF0ZS56b29tLl9fYmFzZUVsZW0ub24oJ2RibGNsaWNrLnpvb20nLCBudWxsKTsgLy8gRGlzYWJsZSBkb3VibGUtY2xpY2sgdG8gem9vbVxuXG4gICAgc3RhdGUuem9vbS5maWx0ZXIoZnVuY3Rpb24gKGV2KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBkaXNhYmxlIHpvb20gaW50ZXJhY3Rpb25cbiAgICAgICAgIWV2LmJ1dHRvbiAmJiBzdGF0ZS5lbmFibGVab29tUGFuSW50ZXJhY3Rpb24gJiYgKGV2LnR5cGUgIT09ICd3aGVlbCcgfHwgYWNjZXNzb3JGbihzdGF0ZS5lbmFibGVab29tSW50ZXJhY3Rpb24pKGV2KSkgJiYgKGV2LnR5cGUgPT09ICd3aGVlbCcgfHwgYWNjZXNzb3JGbihzdGF0ZS5lbmFibGVQYW5JbnRlcmFjdGlvbikoZXYpKVxuICAgICAgKTtcbiAgICB9KS5vbignem9vbScsIGZ1bmN0aW9uIChldikge1xuICAgICAgdmFyIHQgPSBldi50cmFuc2Zvcm07XG4gICAgICBbY3R4LCBzaGFkb3dDdHhdLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmVzZXRUcmFuc2Zvcm0oYyk7XG4gICAgICAgIGMudHJhbnNsYXRlKHQueCwgdC55KTtcbiAgICAgICAgYy5zY2FsZSh0LmssIHQuayk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLm9uWm9vbSAmJiBzdGF0ZS5vblpvb20oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHQpLCBfdGhpcy5jZW50ZXJBdCgpKSk7IC8vIHJlcG9ydCB4LHkgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY2FudmFzIGNlbnRlclxuICAgICAgc3RhdGUubmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgIH0pLm9uKCdlbmQnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBzdGF0ZS5vblpvb21FbmQgJiYgc3RhdGUub25ab29tRW5kKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBldi50cmFuc2Zvcm0pLCBfdGhpcy5jZW50ZXJBdCgpKSk7XG4gICAgfSk7XG4gICAgYWRqdXN0Q2FudmFzU2l6ZShzdGF0ZSk7XG4gICAgc3RhdGUuZm9yY2VHcmFwaC5vbk5lZWRzUmVkcmF3KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdGF0ZS5uZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgfSkub25GaW5pc2hVcGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gcmUtem9vbSwgaWYgc3RpbGwgaW4gZGVmYXVsdCBwb3NpdGlvbiAobm90IHVzZXIgbW9kaWZpZWQpXG4gICAgICBpZiAoem9vbVRyYW5zZm9ybShzdGF0ZS5jYW52YXMpLmsgPT09IHN0YXRlLmxhc3RTZXRab29tICYmIHN0YXRlLmdyYXBoRGF0YS5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgc3RhdGUuem9vbS5zY2FsZVRvKHN0YXRlLnpvb20uX19iYXNlRWxlbSwgc3RhdGUubGFzdFNldFpvb20gPSBaT09NMk5PREVTX0ZBQ1RPUiAvIE1hdGguY2JydChzdGF0ZS5ncmFwaERhdGEubm9kZXMubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLm5lZWRzUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNldHVwIHRvb2x0aXBcbiAgICBzdGF0ZS50b29sdGlwID0gbmV3IFRvb2x0aXAoY29udGFpbmVyKTtcblxuICAgIC8vIENhcHR1cmUgcG9pbnRlciBjb29yZHMgb24gbW92ZSBvciB0b3VjaHN0YXJ0XG4gICAgWydwb2ludGVybW92ZScsICdwb2ludGVyZG93biddLmZvckVhY2goZnVuY3Rpb24gKGV2VHlwZSkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmIChldlR5cGUgPT09ICdwb2ludGVyZG93bicpIHtcbiAgICAgICAgICBzdGF0ZS5pc1BvaW50ZXJQcmVzc2VkID0gdHJ1ZTsgLy8gdHJhY2sgY2xpY2sgc3RhdGVcbiAgICAgICAgICBzdGF0ZS5wb2ludGVyRG93bkV2ZW50ID0gZXY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZXRlY3QgcG9pbnRlciBkcmFnIG9uIGNhbnZhcyBwYW5cbiAgICAgICAgIXN0YXRlLmlzUG9pbnRlckRyYWdnaW5nICYmIGV2LnR5cGUgPT09ICdwb2ludGVybW92ZScgJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgLy8gb25seSBib3RoZXIgZGV0ZWN0aW5nIGRyYWdzIHRoaXMgd2F5IGlmIGJhY2tncm91bmQgY2xpY2tzIGFyZSBlbmFibGVkIChzbyB0aGV5IGRvbid0IHRyaWdnZXIgYWNjaWRlbnRhbGx5IG9uIGNhbnZhcyBwYW5uaW5nKVxuICAgICAgICAmJiAoZXYucHJlc3N1cmUgPiAwIHx8IHN0YXRlLmlzUG9pbnRlclByZXNzZWQpIC8vIGV2LnByZXNzdXJlIGFsd2F5cyAwIG9uIFNhZmFyaSwgc28gd2UgdXNlIHRoZSBpc1BvaW50ZXJQcmVzc2VkIHRyYWNrZXJcbiAgICAgICAgJiYgKGV2LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2Lm1vdmVtZW50WCA9PT0gdW5kZWZpbmVkIHx8IFtldi5tb3ZlbWVudFgsIGV2Lm1vdmVtZW50WV0uc29tZShmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhtKSA+IDE7XG4gICAgICAgIH0pKSAvLyByZWxheCBkcmFnIHRyaWdnZXIgc2Vuc2l0aXZpdHkgb24gbm9uLW1vdXNlICh0b3VjaC9wZW4pIGV2ZW50c1xuICAgICAgICAmJiAoc3RhdGUuaXNQb2ludGVyRHJhZ2dpbmcgPSB0cnVlKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvaW50ZXIgcG9zXG4gICAgICAgIHZhciBvZmZzZXQgPSBnZXRPZmZzZXQoY29udGFpbmVyKTtcbiAgICAgICAgcG9pbnRlclBvcy54ID0gZXYucGFnZVggLSBvZmZzZXQubGVmdDtcbiAgICAgICAgcG9pbnRlclBvcy55ID0gZXYucGFnZVkgLSBvZmZzZXQudG9wO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0KGVsKSB7XG4gICAgICAgICAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiByZWN0LnRvcCArIHNjcm9sbFRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHNjcm9sbExlZnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIGNsaWNrL3RvdWNoIGV2ZW50cyBvbiBub2Rlcy9saW5rc1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmICghc3RhdGUuaXNQb2ludGVyUHJlc3NlZCkge1xuICAgICAgICByZXR1cm47IC8vIGRvbid0IHRyaWdnZXIgY2xpY2sgZXZlbnRzIGlmIHBvaW50ZXIgaXMgbm90IHByZXNzZWQgb24gdGhlIGNhbnZhc1xuICAgICAgfVxuICAgICAgc3RhdGUuaXNQb2ludGVyUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nKSB7XG4gICAgICAgIHN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjsgLy8gZG9uJ3QgdHJpZ2dlciBjbGljayBldmVudHMgYWZ0ZXIgcG9pbnRlciBkcmFnIChwYW4gLyBub2RlIGRyYWcgZnVuY3Rpb25hbGl0eSlcbiAgICAgIH1cbiAgICAgIHZhciBjYkV2ZW50cyA9IFtldiwgc3RhdGUucG9pbnRlckRvd25FdmVudF07XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNsaWNrIGV2ZW50cyBhc3luY2hyb25vdXNseSwgdG8gYWxsb3cgaG92ZXJPYmogdG8gYmUgc2V0IChvbiBmcmFtZSlcbiAgICAgICAgaWYgKGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgIC8vIG1vdXNlIGxlZnQtY2xpY2sgb3IgdG91Y2hcbiAgICAgICAgICBpZiAoc3RhdGUuaG92ZXJPYmopIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHN0YXRlW1wib25cIi5jb25jYXQoc3RhdGUuaG92ZXJPYmoudHlwZSwgXCJDbGlja1wiKV07XG4gICAgICAgICAgICBmbiAmJiBmbi5hcHBseSh2b2lkIDAsIFtzdGF0ZS5ob3Zlck9iai5kXS5jb25jYXQoY2JFdmVudHMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2sgJiYgc3RhdGUub25CYWNrZ3JvdW5kQ2xpY2suYXBwbHkoc3RhdGUsIGNiRXZlbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIC8vIG1vdXNlIHJpZ2h0LWNsaWNrXG4gICAgICAgICAgaWYgKHN0YXRlLmhvdmVyT2JqKSB7XG4gICAgICAgICAgICB2YXIgX2ZuID0gc3RhdGVbXCJvblwiLmNvbmNhdChzdGF0ZS5ob3Zlck9iai50eXBlLCBcIlJpZ2h0Q2xpY2tcIildO1xuICAgICAgICAgICAgX2ZuICYmIF9mbi5hcHBseSh2b2lkIDAsIFtzdGF0ZS5ob3Zlck9iai5kXS5jb25jYXQoY2JFdmVudHMpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUub25CYWNrZ3JvdW5kUmlnaHRDbGljayAmJiBzdGF0ZS5vbkJhY2tncm91bmRSaWdodENsaWNrLmFwcGx5KHN0YXRlLCBjYkV2ZW50cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBpZiAoIXN0YXRlLm9uQmFja2dyb3VuZFJpZ2h0Q2xpY2sgJiYgIXN0YXRlLm9uTm9kZVJpZ2h0Q2xpY2sgJiYgIXN0YXRlLm9uTGlua1JpZ2h0Q2xpY2spIHJldHVybiB0cnVlOyAvLyBkZWZhdWx0IGNvbnRleHRtZW51IGJlaGF2aW9yXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuICAgIHN0YXRlLmZvcmNlR3JhcGgoY3R4KTtcbiAgICBzdGF0ZS5zaGFkb3dHcmFwaChzaGFkb3dDdHgpO1xuXG4gICAgLy9cblxuICAgIHZhciByZWZyZXNoU2hhZG93Q2FudmFzID0gdGhyb3R0bGUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gd2lwZSBjYW52YXNcbiAgICAgIGNsZWFyQ2FudmFzKHNoYWRvd0N0eCwgc3RhdGUud2lkdGgsIHN0YXRlLmhlaWdodCk7XG5cbiAgICAgIC8vIEFkanVzdCBsaW5rIGhvdmVyIGFyZWFcbiAgICAgIHN0YXRlLnNoYWRvd0dyYXBoLmxpbmtXaWR0aChmdW5jdGlvbiAobCkge1xuICAgICAgICByZXR1cm4gYWNjZXNzb3JGbihzdGF0ZS5saW5rV2lkdGgpKGwpICsgc3RhdGUubGlua0hvdmVyUHJlY2lzaW9uO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHJlZHJhd1xuICAgICAgdmFyIHQgPSB6b29tVHJhbnNmb3JtKHN0YXRlLmNhbnZhcyk7XG4gICAgICBzdGF0ZS5zaGFkb3dHcmFwaC5nbG9iYWxTY2FsZSh0LmspLnRpY2tGcmFtZSgpO1xuICAgIH0sIEhPVkVSX0NBTlZBU19USFJPVFRMRV9ERUxBWSk7XG4gICAgc3RhdGUuZmx1c2hTaGFkb3dDYW52YXMgPSByZWZyZXNoU2hhZG93Q2FudmFzLmZsdXNoOyAvLyBob29rIHRvIGltbWVkaWF0ZWx5IGludm9rZSBzaGFkb3cgY2FudmFzIHBhaW50XG5cbiAgICAvLyBLaWNrLW9mZiByZW5kZXJlclxuICAgICh0aGlzLl9hbmltYXRpb25DeWNsZSA9IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgICAvLyBJSUZFXG4gICAgICB2YXIgZG9SZWRyYXcgPSAhc3RhdGUuYXV0b1BhdXNlUmVkcmF3IHx8ICEhc3RhdGUubmVlZHNSZWRyYXcgfHwgc3RhdGUuZm9yY2VHcmFwaC5pc0VuZ2luZVJ1bm5pbmcoKSB8fCBzdGF0ZS5ncmFwaERhdGEubGlua3Muc29tZShmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5fX3Bob3RvbnMgJiYgZC5fX3Bob3RvbnMubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICBzdGF0ZS5uZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgaWYgKHN0YXRlLmVuYWJsZVBvaW50ZXJJbnRlcmFjdGlvbikge1xuICAgICAgICAvLyBVcGRhdGUgdG9vbHRpcCBhbmQgdHJpZ2dlciBvbkhvdmVyIGV2ZW50c1xuICAgICAgICB2YXIgb2JqID0gIXN0YXRlLmlzUG9pbnRlckRyYWdnaW5nID8gZ2V0T2JqVW5kZXJQb2ludGVyKCkgOiBudWxsOyAvLyBkb24ndCBob3ZlciBkdXJpbmcgZHJhZ1xuICAgICAgICBpZiAob2JqICE9PSBzdGF0ZS5ob3Zlck9iaikge1xuICAgICAgICAgIHZhciBwcmV2T2JqID0gc3RhdGUuaG92ZXJPYmo7XG4gICAgICAgICAgdmFyIHByZXZPYmpUeXBlID0gcHJldk9iaiA/IHByZXZPYmoudHlwZSA6IG51bGw7XG4gICAgICAgICAgdmFyIG9ialR5cGUgPSBvYmogPyBvYmoudHlwZSA6IG51bGw7XG4gICAgICAgICAgaWYgKHByZXZPYmpUeXBlICYmIHByZXZPYmpUeXBlICE9PSBvYmpUeXBlKSB7XG4gICAgICAgICAgICAvLyBIb3ZlciBvdXRcbiAgICAgICAgICAgIHZhciBmbiA9IHN0YXRlW1wib25cIi5jb25jYXQocHJldk9ialR5cGUsIFwiSG92ZXJcIildO1xuICAgICAgICAgICAgZm4gJiYgZm4obnVsbCwgcHJldk9iai5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9ialR5cGUpIHtcbiAgICAgICAgICAgIC8vIEhvdmVyIGluXG4gICAgICAgICAgICB2YXIgX2ZuMiA9IHN0YXRlW1wib25cIi5jb25jYXQob2JqVHlwZSwgXCJIb3ZlclwiKV07XG4gICAgICAgICAgICBfZm4yICYmIF9mbjIob2JqLmQsIHByZXZPYmpUeXBlID09PSBvYmpUeXBlID8gcHJldk9iai5kIDogbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLnRvb2x0aXAuY29udGVudChvYmogPyBhY2Nlc3NvckZuKHN0YXRlW1wiXCIuY29uY2F0KG9iai50eXBlLnRvTG93ZXJDYXNlKCksIFwiTGFiZWxcIildKShvYmouZCkgfHwgbnVsbCA6IG51bGwpO1xuXG4gICAgICAgICAgLy8gc2V0IHBvaW50ZXIgaWYgaG92ZXJlZCBvYmplY3QgaXMgY2xpY2thYmxlXG4gICAgICAgICAgc3RhdGUuY2FudmFzLmNsYXNzTGlzdFtvYmogJiYgc3RhdGVbXCJvblwiLmNvbmNhdChvYmpUeXBlLCBcIkNsaWNrXCIpXSB8fCAhb2JqICYmIHN0YXRlLm9uQmFja2dyb3VuZENsaWNrID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ2NsaWNrYWJsZScpO1xuICAgICAgICAgIHN0YXRlLmhvdmVyT2JqID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGRvUmVkcmF3ICYmIHJlZnJlc2hTaGFkb3dDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb1JlZHJhdykge1xuICAgICAgICAvLyBXaXBlIGNhbnZhc1xuICAgICAgICBjbGVhckNhbnZhcyhjdHgsIHN0YXRlLndpZHRoLCBzdGF0ZS5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEZyYW1lIGN5Y2xlXG4gICAgICAgIHZhciBnbG9iYWxTY2FsZSA9IHpvb21UcmFuc2Zvcm0oc3RhdGUuY2FudmFzKS5rO1xuICAgICAgICBzdGF0ZS5vblJlbmRlckZyYW1lUHJlICYmIHN0YXRlLm9uUmVuZGVyRnJhbWVQcmUoY3R4LCBnbG9iYWxTY2FsZSk7XG4gICAgICAgIHN0YXRlLmZvcmNlR3JhcGguZ2xvYmFsU2NhbGUoZ2xvYmFsU2NhbGUpLnRpY2tGcmFtZSgpO1xuICAgICAgICBzdGF0ZS5vblJlbmRlckZyYW1lUG9zdCAmJiBzdGF0ZS5vblJlbmRlckZyYW1lUG9zdChjdHgsIGdsb2JhbFNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnR3ZWVuR3JvdXAudXBkYXRlKCk7IC8vIHVwZGF0ZSBjYW52YXMgYW5pbWF0aW9uIHR3ZWVuc1xuXG4gICAgICBzdGF0ZS5hbmltYXRpb25GcmFtZVJlcXVlc3RJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9KSgpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZUZuKHN0YXRlKSB7fVxufSk7XG5cbmV4cG9ydCB7IGZvcmNlR3JhcGggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/force-graph/dist/force-graph.mjs\n");

/***/ })

};
;